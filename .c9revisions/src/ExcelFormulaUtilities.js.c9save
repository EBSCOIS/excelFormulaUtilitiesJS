{"ts":1349354149147,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * excelFormulaUtilitiesJS\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\n *\n * Copyright 2011, Josh Bennett\n * licensed under the MIT license.\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\n *\n * Some functionality based off of the jquery core lib\n * Copyright 2011, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\n */ (function () {\n    if (typeof window === 'undefined') {\n      window = root;\n    }\n<<<<<<< HEAD\n=======\n\n>>>>>>> rangeHandler\n    var excelFormulaUtilities = window.excelFormulaUtilities = window.excelFormulaUtilities || {},\n    core = window.excelFormulaUtilities.core,\n        formatStr = window.excelFormulaUtilities.string.formatStr,\n        trim = window.excelFormulaUtilities.string.trim,\n\n        types = {},\n        TOK_TYPE_NOOP = types.TOK_TYPE_NOOP = \"noop\",\n        TOK_TYPE_OPERAND = types.TOK_TYPE_OPERAND = \"operand\",\n        TOK_TYPE_FUNCTION = types.TOK_TYPE_FUNCTION = \"function\",\n        TOK_TYPE_SUBEXPR = types.TOK_TYPE_SUBEXPR = \"subexpression\",\n        TOK_TYPE_ARGUMENT = types.TOK_TYPE_ARGUMENT = \"argument\",\n        TOK_TYPE_OP_PRE = types.TOK_TYPE_OP_PRE = \"operator-prefix\",\n        TOK_TYPE_OP_IN = types.TOK_TYPE_OP_IN = \"operator-infix\",\n        TOK_TYPE_OP_POST = types.TOK_TYPE_OP_POST = \"operator-postfix\",\n        TOK_TYPE_WSPACE = types.TOK_TYPE_WSPACE = \"white-space\",\n        TOK_TYPE_UNKNOWN = types.TOK_TYPE_UNKNOWN = \"unknown\",\n\n        TOK_SUBTYPE_START = types.TOK_SUBTYPE_START = \"start\",\n        TOK_SUBTYPE_STOP = types.TOK_SUBTYPE_STOP = \"stop\",\n\n        TOK_SUBTYPE_TEXT = types.TOK_SUBTYPE_TEXT = \"text\",\n        TOK_SUBTYPE_NUMBER = types.TOK_SUBTYPE_NUMBER = \"number\",\n        TOK_SUBTYPE_LOGICAL = types.TOK_SUBTYPE_LOGICAL = \"logical\",\n        TOK_SUBTYPE_ERROR = types.TOK_SUBTYPE_ERROR = \"error\",\n        TOK_SUBTYPE_RANGE = types.TOK_SUBTYPE_RANGE = \"range\",\n\n        TOK_SUBTYPE_MATH = types.TOK_SUBTYPE_MATH = \"math\",\n        TOK_SUBTYPE_CONCAT = types.TOK_SUBTYPE_CONCAT = \"concatenate\",\n        TOK_SUBTYPE_INTERSECT = types.TOK_SUBTYPE_INTERSECT = \"intersect\",\n        TOK_SUBTYPE_UNION = types.TOK_SUBTYPE_UNION = \"union\";\n\n    /**\n     * @class\n     */\n\n    function F_token(value, type, subtype) {\n        this.value = value;\n        this.type = type;\n        this.subtype = subtype;\n    }\n\n    /**\n     * @class\n     */\n\n    function F_tokens() {\n\n        this.items = [];\n\n        this.add = function (value, type, subtype) {\n            if (!subtype) {\n                subtype = \"\";\n            }\n            var token = new F_token(value, type, subtype);\n            this.addRef(token);\n            return token;\n        };\n        this.addRef = function (token) {\n            this.items.push(token);\n        };\n\n        this.index = -1;\n        this.reset = function () {\n            this.index = -1;\n        };\n        this.BOF = function () {\n            return (this.index <= 0);\n        };\n        this.EOF = function () {\n            return (this.index >= (this.items.length - 1));\n        };\n        this.moveNext = function () {\n            if (this.EOF()) {\n                return false;\n            }\n            this.index += 1;\n            return true;\n        };\n        this.current = function () {\n            if (this.index === -1) {\n                return null;\n            }\n            return (this.items[this.index]);\n        };\n        this.next = function () {\n            if (this.EOF()) {\n                return null;\n            }\n            return (this.items[this.index + 1]);\n        };\n        this.previous = function () {\n            if (this.index < 1) {\n                return null;\n            }\n            return (this.items[this.index - 1]);\n        };\n\n    }\n\n    function F_tokenStack() {\n\n        this.items = [];\n\n        this.push = function (token) {\n            this.items.push(token);\n        };\n        this.pop = function (name) {\n            var token = this.items.pop();\n            return (new F_token(name || \"\", token.type, TOK_SUBTYPE_STOP));\n        };\n\n        this.token = function () {\n            return ((this.items.length > 0) ? this.items[this.items.length - 1] : null);\n        };\n        this.value = function () {\n            return ((this.token()) ? this.token().value.toString() : \"\");\n        };\n        this.type = function () {\n            return ((this.token()) ? this.token().type.toString() : \"\");\n        };\n        this.subtype = function () {\n            return ((this.token()) ? this.token().subtype.toString() : \"\");\n        };\n\n    }\n\n    function getTokens(formula) {\n\n        var tokens = new F_tokens(),\n            tokenStack = new F_tokenStack(),\n\n            offset = 0,\n\n            currentChar = function () {\n                return formula.substr(offset, 1);\n            },\n            doubleChar = function () {\n                return formula.substr(offset, 2);\n            },\n            nextChar = function () {\n                return formula.substr(offset + 1, 1);\n            },\n            EOF = function () {\n                return (offset >= formula.length);\n            },\n\n            token = \"\",\n\n            inString = false,\n            inPath = false,\n            inRange = false,\n            inError = false,\n            regexSN = /^[1-9]{1}(\\.[0-9]+)?E{1}$/;\n\n        while (formula.length > 0) {\n            if (formula.substr(0, 1) === \" \") {\n                formula = formula.substr(1);\n            } else {\n                if (formula.substr(0, 1) === \"=\") {\n                    formula = formula.substr(1);\n                }\n                break;\n            }\n        }\n\n\n\n        while (!EOF()) {\n\n            // state-dependent character evaluation (order is important)\n            // double-quoted strings\n            // embeds are doubled\n            // end marks token\n            if (inString) {\n                if (currentChar() === \"\\\"\") {\n                    if (nextChar() === \"\\\"\") {\n                        token += \"\\\"\";\n                        offset += 1;\n                    } else {\n                        inString = false;\n                        tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_TEXT);\n                        token = \"\";\n                    }\n                } else {\n                    token += currentChar();\n                }\n                offset += 1;\n                continue;\n            }\n\n            // single-quoted strings (links)\n            // embeds are double\n            // end does not mark a token\n            if (inPath) {\n                if (currentChar() === \"'\") {\n                    if (nextChar() === \"'\") {\n                        token += \"'\";\n                        offset += 1;\n                    } else {\n                        inPath = false;\n                    }\n                } else {\n                    token += currentChar();\n                }\n                offset += 1;\n                continue;\n            }\n\n            // bracked strings (range offset or linked workbook name)\n            // no embeds (changed to \"()\" by Excel)\n            // end does not mark a token\n            if (inRange) {\n                if (currentChar() === \"]\") {\n                    inRange = false;\n                }\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // error values\n            // end marks a token, determined from absolute list of values\n            if (inError) {\n                token += currentChar();\n                offset += 1;\n                if ((\",#NULL!,#DIV/0!,#VALUE!,#REF!,#NAME?,#NUM!,#N/A,\").indexOf(\",\" + token + \",\") !== -1) {\n                    inError = false;\n                    tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_ERROR);\n                    token = \"\";\n                }\n                continue;\n            }\n\n            // scientific notation check\n            if ((\"+-\").indexOf(currentChar()) !== -1) {\n                if (token.length > 1) {\n                    if (token.match(regexSN)) {\n                        token += currentChar();\n                        offset += 1;\n                        continue;\n                    }\n                }\n            }\n\n            // independent character evaulation (order not important)\n            // establish state-dependent character evaluations\n            if (currentChar() === \"\\\"\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inString = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"'\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inPath = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"[\") {\n                inRange = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"#\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inError = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // mark start and end of arrays and array rows\n            if (currentChar() === \"{\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                tokenStack.push(tokens.add(\"ARRAY\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \";\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop());\n                tokens.add(\",\", TOK_TYPE_ARGUMENT);\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"}\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop(\"ARRAYROWSTOP\"));\n                tokens.addRef(tokenStack.pop(\"ARRAYSTOP\"));\n                offset += 1;\n                continue;\n            }\n\n            // trim white-space\n            if (currentChar() === \" \") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(\"\", TOK_TYPE_WSPACE);\n                offset += 1;\n                while ((currentChar() === \" \") && (!EOF())) {\n                    offset += 1;\n                }\n                continue;\n            }\n\n            // multi-character comparators\n            if ((\",>=,<=,<>,\").indexOf(\",\" + doubleChar() + \",\") !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(doubleChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_LOGICAL);\n                offset += 2;\n                continue;\n            }\n\n            // standard infix operators\n            if ((\"+-*/^&=><\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_IN);\n                offset += 1;\n                continue;\n            }\n\n            // standard postfix operators\n            if ((\"%\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_POST);\n                offset += 1;\n                continue;\n            }\n\n            // start subexpression or function\n            if (currentChar() === \"(\") {\n                if (token.length > 0) {\n                    tokenStack.push(tokens.add(token, TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                    token = \"\";\n                } else {\n                    tokenStack.push(tokens.add(\"\", TOK_TYPE_SUBEXPR, TOK_SUBTYPE_START));\n                }\n                offset += 1;\n                continue;\n            }\n\n            // function, subexpression, array parameters\n            if (currentChar() === \",\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                if (tokenStack.type() !== TOK_TYPE_FUNCTION) {\n                    tokens.add(currentChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_UNION);\n                } else {\n                    tokens.add(currentChar(), TOK_TYPE_ARGUMENT);\n                }\n                offset += 1;\n                continue;\n            }\n\n            // stop subexpression\n            if (currentChar() === \")\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop());\n                offset += 1;\n                continue;\n            }\n\n            // token accumulation\n            token += currentChar();\n            offset += 1;\n\n        }\n\n        // dump remaining accumulation\n        if (token.length > 0) {\n            tokens.add(token, TOK_TYPE_OPERAND);\n        }\n\n        // move all tokens to a new collection, excluding all unnecessary white-space tokens\n        var tokens2 = new F_tokens();\n\n        while (tokens.moveNext()) {\n\n            token = tokens.current();\n\n            if (token.type.toString() === TOK_TYPE_WSPACE) {\n                var doAddToken = (tokens.BOF()) || (tokens.EOF());\n                //if ((tokens.BOF()) || (tokens.EOF())) {}\n                doAddToken = doAddToken && (((tokens.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens.previous().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //       ((tokens.previous().type === TOK_TYPE_FUNCTION) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \n                //    || ((tokens.previous().type == TOK_TYPE_SUBEXPR) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \n                //    || (tokens.previous().type == TOK_TYPE_OPERAND))) \n                //  {}\n                doAddToken = doAddToken && (((tokens.next().type.toString() === TOK_TYPE_FUNCTION) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || ((tokens.next().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || (tokens.next().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //\t((tokens.next().type == TOK_TYPE_FUNCTION) && (tokens.next().subtype == TOK_SUBTYPE_START)) \n                //\t|| ((tokens.next().type == TOK_TYPE_SUBEXPR) && (tokens.next().subtype == TOK_SUBTYPE_START)) \n                //\t|| (tokens.next().type == TOK_TYPE_OPERAND))) \n                //\t{} \n                //else { tokens2.add(token.value, TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT)};\n                if (doAddToken) {\n                    tokens2.add(token.value.toString(), TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT);\n                }\n                continue;\n            }\n\n            tokens2.addRef(token);\n\n        }\n\n        // switch infix \"-\" operator to prefix when appropriate, switch infix \"+\" operator to noop when appropriate, identify operand \n        // and infix-operator subtypes, pull \"@\" from in front of function names\n        while (tokens2.moveNext()) {\n\n            token = tokens2.current();\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"-\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"+\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_NOOP.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_NOOP.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.subtype.length === 0)) {\n                if ((\"<>=\").indexOf(token.value.substr(0, 1)) !== -1) {\n                    token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                } else if (token.value.toString() === \"&\") {\n                    token.subtype = TOK_SUBTYPE_CONCAT.toString();\n                } else {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OPERAND) && (token.subtype.length === 0)) {\n                if (isNaN(parseFloat(token.value))) {\n                    if ((token.value.toString() === 'TRUE') || (token.value.toString() === 'FALSE')) {\n                        token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                    } else {\n                        token.subtype = TOK_SUBTYPE_RANGE.toString();\n                    }\n                } else {\n                    token.subtype = TOK_SUBTYPE_NUMBER.toString();\n                }\n\n                continue;\n            }\n\n            if (token.type.toString() === TOK_TYPE_FUNCTION) {\n                if (token.value.substr(0, 1) === \"@\") {\n                    token.value = token.value.substr(1).toString();\n                }\n                continue;\n            }\n\n        }\n\n        tokens2.reset();\n\n        // move all tokens to a new collection, excluding all noops\n        tokens = new F_tokens();\n\n        while (tokens2.moveNext()) {\n            if (tokens2.current().type.toString() !== TOK_TYPE_NOOP) {\n                tokens.addRef(tokens2.current());\n            }\n        }\n\n        tokens.reset();\n\n        return tokens;\n    }\n\n\n    var parseFormula = excelFormulaUtilities.parseFormula = function (inputID, outputID) {\n\n\n        var indentCount = 0;\n\n        var indent = function () {\n            var s = \"|\",\n                i = 0;\n            for (; i < indentCount; i += 1) {\n                s += \"&nbsp;&nbsp;&nbsp;|\";\n            }\n            return s;\n        };\n\n        var formulaControl = document.getElementById(inputID);\n        var formula = formulaControl.value;\n\n        var tokens = getTokens(formula);\n\n        var tokensHtml = \"\";\n\n        tokensHtml += \"<table cellspacing='0' style='border-top: 1px #cecece solid; margin-top: 5px; margin-bottom: 5px'>\";\n        tokensHtml += \"<tr>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 50px'>index</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>type</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>subtype</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 150px'>token</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 300px'>token tree</td></tr>\";\n\n        while (tokens.moveNext()) {\n\n            var token = tokens.current();\n\n            if (token.subtype === TOK_SUBTYPE_STOP) {\n                indentCount -= ((indentCount > 0) ? 1 : 0);\n            }\n\n            tokensHtml += \"<tr>\";\n\n            tokensHtml += \"<td class='token'>\" + (tokens.index + 1) + \"</td>\";\n\n            tokensHtml += \"<td class='token'>\" + token.type + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + ((token.subtype.length === 0) ? \"&nbsp;\" : token.subtype.toString()) + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + indent() + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n\n            tokensHtml += \"</tr>\";\n\n            if (token.subtype === TOK_SUBTYPE_START) {\n                indentCount += 1;\n            }\n\n        }\n<<<<<<< HEAD\n\n        tokensHtml += \"</table>\";\n\n        document.getElementById(outputID).innerHTML = tokensHtml;\n\n        formulaControl.select();\n        formulaControl.focus();\n\n    };\n\n    // Pass a range such as A1:B2 along with a \n    // delimiter to get back a full list of ranges.\n    //\n    // Example:\n    //    breakOutRanges(\"A1:B2\", \"+\"); //Returns A1+A2+B1+B2\n    //TODO finish this function.\n    function breakOutRanges(rangeStr, delimStr){\n        \n        //Quick Check to see if if rangeStr is a valid range\n        if ( (/\\w{1,4}\\d+:\\w{1,4}\\d+/gi).test(\"A1:B2\") ){\n            throw \"This is not a valid range: \" + rangeStr;\n        }\n        \n        //Make the rangeStr lowercase to deal with looping.\n        ranges = rangeStr.split(\":\");\n        \n        startRow = range[0].match(/[0-9]+/gi)[0];\n        startCol = range[0].match(/[A-Z]+/gi)[0];\n        \n        endRow = range[1].match(/[0-9]+/gi)[0];\n        endCol = range[1].match(/[A-Z]+/gi)[0];\n        \n        //str.charCodeAt(n)\n        //String.fromCharCode();\n    }\n    \n    //Modified from function at http://en.wikipedia.org/wiki/Hexavigesimal\n    function toBase26( value ) {\n       \n       value = Math.abs(value);\n       \n       var converted = \"\"\n            ,iteration = false\n            ,remainder;\n\n       // Repeatedly divide the numerb by 26 and convert the\n       // remainder into the appropriate letter.\n       do {\n           remainder = value % 26;\n\n           // Compensate for the last letter of the series being corrected on 2 or more iterations.\n           if (iteration && value < 25) {\n               remainder--;\n           }\n            \n           converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;\n           value = Math.floor((value - remainder) / 26);\n\n           iteration = true;\n       } while (value > 0);\n\n       return converted;\n   }\n   \n   // This was Modified from a function at http://en.wikipedia.org/wiki/Hexavigesimal\n   // Pass in the base 26 string, get back integer\n    function fromBase26(number) {\n        number = number.toUpperCase();\n        \n        var s = 0\n            ,i = 1;\n        \n        if (\n            number !== null \n            && typeof number !== \"undefined\" \n            && number.length > 0\n        ) {\n            s = (number.charCodeAt(0) - \"A\".charCodeAt(0));\n            for (; i < number.length; i++) {\n                s = s === 0 ? 26 : s * 26;\n                s += (number.charCodeAt(i) - (\"A\".charCodeAt(0) ));\n            }\n        }\n        \n        return s;\n    }\n    \n    function applyTokenTemplate(token, options, indent, lineBreak, override) {\n\n        var indt = indent;\n\n        var replaceTokenTmpl = function (inStr) {\n            return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\n        };\n\n        var tokenString = \"\";\n\n        if (token.subtype === \"text\" || token.type === \"text\") {\n            tokenString = token.value.toString();\n        } else {\n            tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\n        }\n\n        if (typeof override === 'function') {\n            var returnVal = override(tokenString, token, indent, lineBreak);\n\n            tokenString = returnVal.tokenString;\n\n=======\n\n        tokensHtml += \"</table>\";\n\n        document.getElementById(outputID).innerHTML = tokensHtml;\n\n        formulaControl.select();\n        formulaControl.focus();\n\n    };\n\n    // Pass a range such as A1:B2 along with a \n    // delimiter to get back a full list of ranges.\n    //\n    // Example:\n    //    breakOutRanges(\"A1:B2\", \"+\"); //Returns A1+A2+B1+B2\n    //TODO finish this function.\n    function breakOutRanges(rangeStr, delimStr){\n        \n        //Quick Check to see if if rangeStr is a valid range\n        if ( (/\\w{1,4}\\d+:\\w{1,4}\\d+/gi).test(\"A1:B2\") ){\n            throw \"This is not a valid range: \" + rangeStr;\n        }\n        \n        //Make the rangeStr lowercase to deal with looping.\n        ranges = rangeStr.split(\":\");\n        \n        startRow = range[0].match(/[0-9]+/gi)[0];\n        startCol = range[0].match(/[A-Z]+/gi)[0];\n        \n        endRow = range[1].match(/[0-9]+/gi)[0];\n        endCol = range[1].match(/[A-Z]+/gi)[0];\n        \n        debugger;\n        //str.charCodeAt(n)\n        //String.fromCharCode();\n        return \"\";\n    }\n    \n    //Modified from function at http://en.wikipedia.org/wiki/Hexavigesimal\n    function toBase26( value ) {\n       \n       value = Math.abs(value);\n       \n       var converted = \"\"\n            ,iteration = false\n            ,remainder;\n\n       // Repeatedly divide the numerb by 26 and convert the\n       // remainder into the appropriate letter.\n       do {\n           remainder = value % 26;\n\n           // Compensate for the last letter of the series being corrected on 2 or more iterations.\n           if (iteration && value < 25) {\n               remainder--;\n           }\n            \n           converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;\n           value = Math.floor((value - remainder) / 26);\n\n           iteration = true;\n       } while (value > 0);\n\n       return converted;\n   }\n   \n   // This was Modified from a function at http://en.wikipedia.org/wiki/Hexavigesimal\n   // Pass in the base 26 string, get back integer\n    function fromBase26(number) {\n        number = number.toUpperCase();\n        \n        var s = 0\n            ,i = 1;\n        \n        if (\n            number !== null \n            && typeof number !== \"undefined\" \n            && number.length > 0\n        ) {\n            s = (number.charCodeAt(0) - \"A\".charCodeAt(0));\n            for (; i < number.length; i++) {\n                s = s === 0 ? 26 : s * 26;\n                s += (number.charCodeAt(i) - (\"A\".charCodeAt(0) ));\n            }\n        }\n        \n        return s;\n    }\n    \n    function applyTokenTemplate(token, options, indent, lineBreak, override) {\n\n        var indt = indent;\n\n        var replaceTokenTmpl = function (inStr) {\n            return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\n        };\n\n        var tokenString = \"\";\n\n        if (token.subtype === \"text\" || token.type === \"text\") {\n            tokenString = token.value.toString();\n        } else {\n            tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\n        }\n\n        if (typeof override === 'function') {\n            var returnVal = override(tokenString, token, indent, lineBreak);\n\n            tokenString = returnVal.tokenString;\n\n>>>>>>> rangeHandler\n            if (!returnVal.useTemplate) {\n                return tokenString;\n            }\n        }\n\n        switch (token.type) {\n\n        case \"function\":\n            //-----------------FUNCTION------------------\n            switch (token.value) {\n            case \"ARRAY\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArray), tokenString, indt, lineBreak);\n                break;\n            case \"ARRAYROW\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArrayRow), tokenString, indt, lineBreak);\n                break;\n            default:\n                if (token.subtype.toString() === \"start\") {\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStart), tokenString, indt, lineBreak);\n                } else {\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStop), tokenString, indt, lineBreak);\n                }\n                break;\n            }\n            break;\n        case \"operand\":\n            //-----------------OPERAND------------------\n            switch (token.subtype.toString()) {\n            case \"error\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandError), tokenString, indt, lineBreak);\n                break;\n            case \"range\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandRange), tokenString, indt, lineBreak);\n                break;\n            case \"number\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandNumber), tokenString, indt, lineBreak);\n                break;\n            case \"text\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandText), tokenString, indt, lineBreak);\n                break;\n            case \"argument\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n                break;\n            default:\n                break;\n            }\n            break;\n        case \"operator-infix\":\n        case \"logical\":\n            tokenString = formatStr(replaceTokenTmpl(options.tmplOperandLogical), tokenString, indt, lineBreak);\n            break;\n        case \"argument\":\n            tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n            break;\n        case \"subexpression\":\n            if (token.subtype.toString() === \"start\") {\n                tokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStart), tokenString, indt, lineBreak);\n            } else {\n                tokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStop), tokenString, indt, lineBreak);\n            }\n            break;\n        default:\n\n            break;\n<<<<<<< HEAD\n\n        }\n\n\n=======\n        }\n>>>>>>> rangeHandler\n        return tokenString;\n    };\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n     *<pre>\n     *   TEMPLATE VALUES \n     *  {{autoindent}} - apply auto indent based on current tree level\n     *  {{token}} - the named token such as FUNCTION_NAME or \"string\"\n     *  {{autolinebreak}} - apply linbreak automaticly. tests for next element only at this point\n     *\n     * Options include:\n     *  tmplFunctionStart           - template for the start of a function, the {{token}} will contain the name of the function.\n     *  tmplFunctionStop            - template for when the end of a function has been reached.\n     *  tmplOperandError            - template for errors.\n     *  tmplOperandRange            - template for ranges and variable names.\n     *  tmplOperandLogical          - template for logical operators such as + - = ...\n     *  tmplOperandNumber           - template for numbers.\n     *  tmplOperandText             - template for text/strings.\n     *  tmplArgument\t\t\t\t- template for argument seperators such as ,.\n     *  tmplFunctionStartArray      - template for the start of an array.\n     *  tmplFunctionStartArrayRow   - template for the start of an array row.\n     *  tmplFunctionStopArrayRow    - template for the end of an array row.\n     *  tmplFunctionStopArray       - template for the end of an array.\n     *  tmplSubexpressionStart      - template for the sub expresson start\n     *  tmplSubexpressionStop       - template for the sub expresson stop\n     *  tmplIndentTab               - template for the tab char.\n     *  tmplIndentSpace             - template for space char.\n     *  autoLineBreak               - when rendering line breaks automaticly which types should it break on. \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\"\n     *  newLine                     - used for the {{autolinebreak}} replacement as well as some string parsing. if this is not set correctly you may get undesired results. usually \\n for text or <br /> for html\n     *  trim: true                  - trim the output.\n     *\tcustomTokenRender: null     - this is a call back to a custom token function. your call back should look like\n     *                                EXAMPLE:\n     *                                 \n     *                                    customTokenRender: function(tokenString, token, indent, linbreak){\n     *                                        var outstr = token,\n     *                                            useTemplate = true;\n     *                                        // In the return object \"useTemplate\" tells formatFormula() \n     *                                        // weather or not to apply the template to what your return from the \"tokenString\".\n     *                                        return {tokenString: outstr, useTemplate: useTemplate}; \n     *                                    }\n     *                                    \n     *</pre>\n     * @returns {string}\n     */\n    var formatFormula = excelFormulaUtilities.formatFormula = function (formula, options) {\n        var isFirstToken = true,\n            defaultOptions = {\n                tmplFunctionStart: '{{autoindent}}{{token}}\\n{{autoindent}}(\\n',\n                tmplFunctionStop: '\\n{{autoindent}}{{token}})',\n                tmplOperandError: '{{token}}',\n                tmplOperandRange: '{{autoindent}}{{token}}',\n                tmplOperandLogical: ' {{token}}{{autolinebreak}}',\n                tmplOperandNumber: '{{autoindent}}{{token}}',\n                tmplOperandText: '{{autoindent}}\"{{token}}\"',\n                tmplArgument: '{{token}}\\n',\n                tmplFunctionStartArray: '',\n                tmplFunctionStartArrayRow: '{',\n                tmplFunctionStopArrayRow: '}',\n                tmplFunctionStopArray: '',\n                tmplSubexpressionStart: '{{autoindent}}(',\n                tmplSubexpressionStop: ' )',\n                tmplIndentTab: '\\t',\n                tmplIndentSpace: ' ',\n                autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n                newLine: '\\n',\n                trim: true,\n                customTokenRender: null\n            };\n\n        if (options) {\n            options = core.extend(true, defaultOptions, options);\n        } else {\n            options = defaultOptions;\n        }\n\n        var indentCount = 0;\n\n        var indent = function () {\n            var s = \"\",\n                i = 0;\n\n            for (; i < indentCount; i += 1) {\n                s += options.tmplIndentTab;\n            }\n            return s;\n        };\n\n        var tokens = getTokens(formula);\n\n        var outputFormula = \"\";\n\n        var autoBreakArray = options.autoLineBreak.replace(/\\s/gi, \"\").split(\"|\");\n\n        //Tokens\n        var isNewLine = true;\n\n        var testAutoBreak = function (nextToken) {\n            var i = 0;\n            for (; i < autoBreakArray.length; i += 1) {\n                if (nextToken !== null && typeof nextToken !== 'undefined' && (types[autoBreakArray[i]] === nextToken.type.toString() || types[autoBreakArray[i]] === nextToken.subtype.toString())) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        while (tokens.moveNext()) {\n\n            var token = tokens.current();\n            var nextToken = tokens.next();\n\n            if (token.subtype.toString() === TOK_SUBTYPE_STOP) {\n                indentCount -= ((indentCount > 0) ? 1 : 0);\n            }\n\n            var matchBeginNewline = new RegExp('^' + options.newLine, ''),\n                matchEndNewLine = new RegExp(options.newLine + '$', ''),\n                autoBreak = testAutoBreak(nextToken),\n                autoIndent = isNewLine,\n                indt = autoIndent ? indent() : options.tmplIndentSpace,\n                lineBreak = autoBreak ? options.newLine : \"\";\n\n            outputFormula += applyTokenTemplate(token, options, indt, lineBreak, options.customTokenRender);\n\n            if (token.subtype.toString() === TOK_SUBTYPE_START) {\n                indentCount += 1;\n\n            }\n\n            isNewLine = autoBreak || matchEndNewLine.test(outputFormula);\n            isFirstToken = false;\n        }\n\n        return options.trim ? trim(outputFormula) : outputFormula;\n    };\n    /**\n     * This function calls {@link excelFormulaUtilities.parser.formatFormula}\n     *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n     */\n    var formatFormulaHTML = excelFormulaUtilities.formatFormulaHTML = function (formula) {\n        var options = {\n            tmplFunctionStart: '{{autoindent}}<span class=\"function\">{{token}}</span><br />{{autoindent}}<span class=\"function_start\">(</span><br />',\n            tmplFunctionStop: '<br />{{autoindent}}{{token}}<span class=\"function_stop\">)</span>',\n            tmplOperandError: '{{token}}',\n            tmplOperandRange: '{{autoindent}}{{token}}',\n            tmplOperandLogical: ' {{token}}{{autolinebreak}}',\n            tmplOperandNumber: '{{autoindent}}{{token}}',\n            tmplOperandText: '{{autoindent}}<span class=\"quote_mark\">\"</span><span class=\"text\">{{token}}</span><span class=\"quote_mark\">\"</span>',\n            tmplArgument: '{{token}}<br />',\n            tmplFunctionStartArray: '',\n            tmplFunctionStartArrayRow: '{',\n            tmplFunctionStopArrayRow: '}',\n            tmplFunctionStopArray: '',\n            tmplSubexpressionStart: '{{autoindent}}(',\n            tmplSubexpressionStop: ' )',\n            tmplIndentTab: '<span class=\"tabs\">&nbsp;&nbsp;&nbsp;&nbsp;</span>',\n            tmplIndentSpace: '&nbsp;',\n            newLine: '<br />',\n            autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n            trim: true,\n            customTokenRender: null\n        };\n\n        return formatFormula(formula, options);\n    }\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2CSharp = excelFormulaUtilities.formula2CSharp = function (formula) {\n\n        //Custom callback to format as c#\n        var functionStack = [];\n\n        var tokRender = function (tokenStr, token, indent, linbreak) {\n            var outstr = \"\",\n                /*tokenString = (token.value.length === 0) ? \"\" : token.value.toString(),*/\n                tokenString = tokenStr,\n                directConversionMap = {\n                    \"=\": \"==\",\n                    \"<>\": \"!=\",\n                    \"MIN\": \"Math.Min\",\n                    \"MAX\": \"Math.Max\",\n                    \"ABS\": \"Math.ABS\",\n                    \"SUM\": \"\",\n                    \"IF\": \"\",\n                    \"&\": \"+\"\n                },\n                currentFunctionOnStack = functionStack[functionStack.length - 1],\n                useTemplate = false;\n\n            switch (token.type.toString()) {\n\n            case TOK_TYPE_FUNCTION:\n\n                switch (token.subtype) {\n\n                case TOK_SUBTYPE_START:\n\n                    functionStack.push({\n                        name: tokenString,\n                        argumentNumber: 0\n                    });\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n\n                    break;\n\n                case TOK_SUBTYPE_STOP:\n\n                    useTemplate = true;\n                    switch (currentFunctionOnStack.name.toLowerCase()) {\n                    case \"if\":\n                        outstr = \")\";\n                        useTemplate = false;\n                        break;\n                    default:\n                        outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                        break\n                    }\n                    functionStack.pop();\n                    break;\n                }\n\n                break;\n\n            case TOK_TYPE_ARGUMENT:\n                switch (currentFunctionOnStack.name.toLowerCase()) {\n                case \"if\":\n                    switch (currentFunctionOnStack.argumentNumber) {\n                    case 0:\n                        outstr = \"?\";\n<<<<<<< HEAD\n                        break;\n                    case 1:\n                        outstr = \":\";\n                        break;\n=======\n                        break;\n                    case 1:\n                        outstr = \":\";\n                        break;\n>>>>>>> rangeHandler\n                    }\n                    break;\n                case \"sum\":\n                    outstr = \"+\";\n                    break;\n                default:\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n                    break;\n                }\n\n                currentFunctionOnStack.argumentNumber += 1;\n\n                break;\n\n            case TOK_TYPE_OPERAND:\n                \n                switch (token.subtype) {\n                    \n                    case TOK_SUBTYPE_RANGE:\n                        \n                        switch (currentFunctionOnStack.name.toLowerCase()) {\n                        // If in the sum function break aout cell names and add\n                        case \"sum\":\n<<<<<<< HEAD\n                            console.log(tokenString);\n=======\n                            outstr = breakOutRanges(tokenString, \"+\");\n\t\t\t\t\t\t\t\n>>>>>>> rangeHandler\n                            debugger;\n                            //TODO loop through and add ranges together\n                            break;\n                        // By Default return an array containing all cell names in array\n                        default:\n                            //TODO create array for ranges\n                            break;\n                        }\n                        \n                        break;\n                    \n                    default:\n                        break;\n                }\n\n            default:\n                outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                useTemplate = true;\n                break;\n            }\n\n            return {\n                tokenString: outstr,\n                useTemplate: useTemplate\n            };\n        };\n\n        var cSharpOutput = formatFormula(\n        formula, {\n            tmplFunctionStart: '{{token}}(',\n            tmplFunctionStop: '{{token}})',\n            tmplOperandError: '{{token}}',\n            tmplOperandRange: '{{token}}',\n            tmplOperandLogical: '{{token}}',\n            tmplOperandNumber: '{{token}}',\n            tmplOperandText: '\"{{token}}\"',\n            tmplArgument: '{{token}}',\n            tmplFunctionStartArray: \"\",\n            tmplFunctionStartArrayRow: \"{\",\n            tmplFunctionStopArrayRow: \"}\",\n            tmplFunctionStopArray: \"\",\n            tmplSubexpressionStart: \"(\",\n            tmplSubexpressionStop: \")\",\n            tmplIndentTab: \"\\t\",\n            tmplIndentSpace: \" \",\n            autoLineBreak: \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\",\n            trim: true,\n            customTokenRender: tokRender\n        });\n        return cSharpOutput;\n    };\n\n    /**\n     * Both the csharp and javascript are the same when converted, this is just an alias for convert2CSharp. there are some subtle differences such as == vrs ===, this will be addressed in a later version.\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2JavaScript = excelFormulaUtilities.formula2JavaScript = function (formula) {\n        return formula2CSharp(formula).replace('==', '===');\n    }\n\n    excelFormulaUtilities.getTokens = getTokens;\n<<<<<<< HEAD\n}());\n=======\n}());\n>>>>>>> rangeHandler\n"]],"start1":0,"start2":0,"length1":0,"length2":46148}]],"length":46148}
{"contributors":[],"silentsave":false,"ts":1349354158093,"patch":[[{"diffs":[[0,"  }\n"],[-1,"<<<<<<< HEAD\n=======\n\n>>>>>>> rangeHandler"],[1,"    "],[0,"\n   "]],"start1":621,"start2":621,"length1":50,"length2":12}]],"length":46110,"saved":false}
{"contributors":[],"silentsave":false,"ts":1349354399833,"patch":[[{"diffs":[[0,"root;\n    }\n"],[-1,"    "],[0,"\n    var exc"]],"start1":613,"start2":613,"length1":28,"length2":24}]],"length":46106,"saved":false}
{"ts":1349354435876,"patch":[[{"diffs":[[0,"   }"],[-1,"\n<<<<<<< HEAD\n\n        tokensHtml += \"</table>\";\n\n        document.getElementById(outputID).innerHTML = tokensHtml;\n\n        formulaControl.select();\n        formulaControl.focus();\n\n    };\n\n    // Pass a range such as A1:B2 along with a \n    // delimiter to get back a full list of ranges.\n    //\n    // Example:\n    //    breakOutRanges(\"A1:B2\", \"+\"); //Returns A1+A2+B1+B2\n    //TODO finish this function.\n    function breakOutRanges(rangeStr, delimStr){\n        \n        //Quick Check to see if if rangeStr is a valid range\n        if ( (/\\w{1,4}\\d+:\\w{1,4}\\d+/gi).test(\"A1:B2\") ){\n            throw \"This is not a valid range: \" + rangeStr;\n        }\n        \n        //Make the rangeStr lowercase to deal with looping.\n        ranges = rangeStr.split(\":\");\n        \n        startRow = range[0].match(/[0-9]+/gi)[0];\n        startCol = range[0].match(/[A-Z]+/gi)[0];\n        \n        endRow = range[1].match(/[0-9]+/gi)[0];\n        endCol = range[1].match(/[A-Z]+/gi)[0];\n        \n        //str.charCodeAt(n)\n        //String.fromCharCode();\n    }\n    \n    //Modified from function at http://en.wikipedia.org/wiki/Hexavigesimal\n    function toBase26( value ) {\n       \n       value = Math.abs(value);\n       \n       var converted = \"\"\n            ,iteration = false\n            ,remainder;\n\n       // Repeatedly divide the numerb by 26 and convert the\n       // remainder into the appropriate letter.\n       do {\n           remainder = value % 26;\n\n           // Compensate for the last letter of the series being corrected on 2 or more iterations.\n           if (iteration && value < 25) {\n               remainder--;\n           }\n            \n           converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;\n           value = Math.floor((value - remainder) / 26);\n\n           iteration = true;\n       } while (value > 0);\n\n       return converted;\n   }\n   \n   // This was Modified from a function at http://en.wikipedia.org/wiki/Hexavigesimal\n   // Pass in the base 26 string, get back integer\n    function fromBase26(number) {\n        number = number.toUpperCase();\n        \n        var s = 0\n            ,i = 1;\n        \n        if (\n            number !== null \n            && typeof number !== \"undefined\" \n            && number.length > 0\n        ) {\n            s = (number.charCodeAt(0) - \"A\".charCodeAt(0));\n            for (; i < number.length; i++) {\n                s = s === 0 ? 26 : s * 26;\n                s += (number.charCodeAt(i) - (\"A\".charCodeAt(0) ));\n            }\n        }\n        \n        return s;\n    }\n    \n    function applyTokenTemplate(token, options, indent, lineBreak, override) {\n\n        var indt = indent;\n\n        var replaceTokenTmpl = function (inStr) {\n            return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\n        };\n\n        var tokenString = \"\";\n\n        if (token.subtype === \"text\" || token.type === \"text\") {\n            tokenString = token.value.toString();\n        } else {\n            tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\n        }\n\n        if (typeof override === 'function') {\n            var returnVal = override(tokenString, token, indent, lineBreak);\n\n            tokenString = returnVal.tokenString;\n\n======="],[0,"\n\n  "]],"start1":22176,"start2":22176,"length1":3358,"length2":8}]],"length":42756,"saved":false}
{"ts":1349354439414,"patch":[[{"diffs":[[0,"   \n        "],[-1,"debugger;"],[0,"\n        //s"]],"start1":23149,"start2":23149,"length1":33,"length2":24}]],"length":42747,"saved":false}
{"ts":1349354441127,"patch":[[{"diffs":[[0,"       \n"],[-1,"        \n"],[0,"        "]],"start1":23145,"start2":23145,"length1":25,"length2":16}]],"length":42738,"saved":false}
{"ts":1349354454104,"patch":[[{"diffs":[[0,"tring;\n\n"],[-1,">>>>>>> rangeHandler\n"],[0,"        "]],"start1":25521,"start2":25521,"length1":37,"length2":16}]],"length":42717,"saved":false}
