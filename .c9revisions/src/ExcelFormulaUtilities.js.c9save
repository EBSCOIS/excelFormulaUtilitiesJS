{"ts":1342443826911,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\r\n * excelFormulaUtilitiesJS\r\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\r\n *\r\n * Copyright 2011, Josh Bennett\r\n * licensed under the MIT license.\r\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\r\n *\r\n * Some functionality based off of the jquery core lib\r\n * Copyright 2011, John Resig\r\n * Dual licensed under the MIT or GPL Version 2 licenses.\r\n * http://jquery.org/license\r\n *\r\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\r\n */\r\n(function () {\r\n    var excelFormulaUtilities = window.excelFormulaUtilities = window.excelFormulaUtilities || {},\r\n        core = window.excelFormulaUtilities.core,\r\n        formatStr = window.excelFormulaUtilities.string.formatStr,\r\n        trim = window.excelFormulaUtilities.string.trim,\r\n\r\n        types = {},\r\n        TOK_TYPE_NOOP = types.TOK_TYPE_NOOP = \"noop\",\r\n        TOK_TYPE_OPERAND = types.TOK_TYPE_OPERAND = \"operand\",\r\n        TOK_TYPE_FUNCTION = types.TOK_TYPE_FUNCTION = \"function\",\r\n        TOK_TYPE_SUBEXPR = types.TOK_TYPE_SUBEXPR = \"subexpression\",\r\n        TOK_TYPE_ARGUMENT = types.TOK_TYPE_ARGUMENT = \"argument\",\r\n        TOK_TYPE_OP_PRE = types.TOK_TYPE_OP_PRE = \"operator-prefix\",\r\n        TOK_TYPE_OP_IN = types.TOK_TYPE_OP_IN = \"operator-infix\",\r\n        TOK_TYPE_OP_POST = types.TOK_TYPE_OP_POST = \"operator-postfix\",\r\n        TOK_TYPE_WSPACE = types.TOK_TYPE_WSPACE = \"white-space\",\r\n        TOK_TYPE_UNKNOWN = types.TOK_TYPE_UNKNOWN = \"unknown\",\r\n\r\n        TOK_SUBTYPE_START = types.TOK_SUBTYPE_START = \"start\",\r\n        TOK_SUBTYPE_STOP = types.TOK_SUBTYPE_STOP = \"stop\",\r\n\r\n        TOK_SUBTYPE_TEXT = types.TOK_SUBTYPE_TEXT = \"text\",\r\n        TOK_SUBTYPE_NUMBER = types.TOK_SUBTYPE_NUMBER = \"number\",\r\n        TOK_SUBTYPE_LOGICAL = types.TOK_SUBTYPE_LOGICAL = \"logical\",\r\n        TOK_SUBTYPE_ERROR = types.TOK_SUBTYPE_ERROR = \"error\",\r\n        TOK_SUBTYPE_RANGE = types.TOK_SUBTYPE_RANGE = \"range\",\r\n\r\n        TOK_SUBTYPE_MATH = types.TOK_SUBTYPE_MATH = \"math\",\r\n        TOK_SUBTYPE_CONCAT = types.TOK_SUBTYPE_CONCAT = \"concatenate\",\r\n        TOK_SUBTYPE_INTERSECT = types.TOK_SUBTYPE_INTERSECT = \"intersect\",\r\n        TOK_SUBTYPE_UNION = types.TOK_SUBTYPE_UNION = \"union\";\r\n\r\n    /**\r\n     * @class\r\n     */\r\n\r\n    function F_token(value, type, subtype) {\r\n        this.value = value;\r\n        this.type = type;\r\n        this.subtype = subtype;\r\n    }\r\n\r\n    /**\r\n     * @class\r\n     */\r\n\r\n    function F_tokens() {\r\n\r\n        this.items = [];\r\n\r\n        this.add = function (value, type, subtype) {\r\n            if (!subtype) {\r\n                subtype = \"\";\r\n            }\r\n            var token = new F_token(value, type, subtype);\r\n            this.addRef(token);\r\n            return token;\r\n        };\r\n        this.addRef = function (token) {\r\n            this.items.push(token);\r\n        };\r\n\r\n        this.index = -1;\r\n        this.reset = function () {\r\n            this.index = -1;\r\n        };\r\n        this.BOF = function () {\r\n            return (this.index <= 0);\r\n        };\r\n        this.EOF = function () {\r\n            return (this.index >= (this.items.length - 1));\r\n        };\r\n        this.moveNext = function () {\r\n            if (this.EOF()) {\r\n                return false;\r\n            }\r\n            this.index += 1;\r\n            return true;\r\n        };\r\n        this.current = function () {\r\n            if (this.index === -1) {\r\n                return null;\r\n            }\r\n            return (this.items[this.index]);\r\n        };\r\n        this.next = function () {\r\n            if (this.EOF()) {\r\n                return null;\r\n            }\r\n            return (this.items[this.index + 1]);\r\n        };\r\n        this.previous = function () {\r\n            if (this.index < 1) {\r\n                return null;\r\n            }\r\n            return (this.items[this.index - 1]);\r\n        };\r\n\r\n    }\r\n\r\n    function F_tokenStack() {\r\n\r\n        this.items = [];\r\n\r\n        this.push = function (token) {\r\n            this.items.push(token);\r\n        };\r\n        this.pop = function (name) {\r\n            var token = this.items.pop();\r\n            return (new F_token(name || \"\", token.type, TOK_SUBTYPE_STOP));\r\n        };\r\n\r\n        this.token = function () {\r\n            return ((this.items.length > 0) ? this.items[this.items.length - 1] : null);\r\n        };\r\n        this.value = function () {\r\n            return ((this.token()) ? this.token().value.toString() : \"\");\r\n        };\r\n        this.type = function () {\r\n            return ((this.token()) ? this.token().type.toString() : \"\");\r\n        };\r\n        this.subtype = function () {\r\n            return ((this.token()) ? this.token().subtype.toString() : \"\");\r\n        };\r\n\r\n    }\r\n\r\n    function getTokens(formula) {\r\n\r\n        var tokens = new F_tokens(),\r\n            tokenStack = new F_tokenStack(),\r\n\r\n            offset = 0,\r\n\r\n            currentChar = function () {\r\n                return formula.substr(offset, 1);\r\n            },\r\n            doubleChar = function () {\r\n                return formula.substr(offset, 2);\r\n            },\r\n            nextChar = function () {\r\n                return formula.substr(offset + 1, 1);\r\n            },\r\n            EOF = function () {\r\n                return (offset >= formula.length);\r\n            },\r\n\r\n            token = \"\",\r\n\r\n            inString = false,\r\n            inPath = false,\r\n            inRange = false,\r\n            inError = false,\r\n            regexSN = /^[1-9]{1}(\\.[0-9]+)?E{1}$/;\r\n\r\n        while (formula.length > 0) {\r\n            if (formula.substr(0, 1) === \" \") {\r\n                formula = formula.substr(1);\r\n            } else {\r\n                if (formula.substr(0, 1) === \"=\") {\r\n                    formula = formula.substr(1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        while (!EOF()) {\r\n\r\n            // state-dependent character evaluation (order is important)\r\n            // double-quoted strings\r\n            // embeds are doubled\r\n            // end marks token\r\n            if (inString) {\r\n                if (currentChar() === \"\\\"\") {\r\n                    if (nextChar() === \"\\\"\") {\r\n                        token += \"\\\"\";\r\n                        offset += 1;\r\n                    } else {\r\n                        inString = false;\r\n                        tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_TEXT);\r\n                        token = \"\";\r\n                    }\r\n                } else {\r\n                    token += currentChar();\r\n                }\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // single-quoted strings (links)\r\n            // embeds are double\r\n            // end does not mark a token\r\n            if (inPath) {\r\n                if (currentChar() === \"'\") {\r\n                    if (nextChar() === \"'\") {\r\n                        token += \"'\";\r\n                        offset += 1;\r\n                    } else {\r\n                        inPath = false;\r\n                    }\r\n                } else {\r\n                    token += currentChar();\r\n                }\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // bracked strings (range offset or linked workbook name)\r\n            // no embeds (changed to \"()\" by Excel)\r\n            // end does not mark a token\r\n            if (inRange) {\r\n                if (currentChar() === \"]\") {\r\n                    inRange = false;\r\n                }\r\n                token += currentChar();\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // error values\r\n            // end marks a token, determined from absolute list of values\r\n            if (inError) {\r\n                token += currentChar();\r\n                offset += 1;\r\n                if ((\",#NULL!,#DIV/0!,#VALUE!,#REF!,#NAME?,#NUM!,#N/A,\").indexOf(\",\" + token + \",\") !== -1) {\r\n                    inError = false;\r\n                    tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_ERROR);\r\n                    token = \"\";\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // scientific notation check\r\n            if ((\"+-\").indexOf(currentChar()) !== -1) {\r\n                if (token.length > 1) {\r\n                    if (token.match(regexSN)) {\r\n                        token += currentChar();\r\n                        offset += 1;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // independent character evaulation (order not important)\r\n            // establish state-dependent character evaluations\r\n            if (currentChar() === \"\\\"\") {\r\n                if (token.length > 0) {\r\n                    // not expected\r\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\r\n                    token = \"\";\r\n                }\r\n                inString = true;\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            if (currentChar() === \"'\") {\r\n                if (token.length > 0) {\r\n                    // not expected\r\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\r\n                    token = \"\";\r\n                }\r\n                inPath = true;\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            if (currentChar() === \"[\") {\r\n                inRange = true;\r\n                token += currentChar();\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            if (currentChar() === \"#\") {\r\n                if (token.length > 0) {\r\n                    // not expected\r\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\r\n                    token = \"\";\r\n                }\r\n                inError = true;\r\n                token += currentChar();\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // mark start and end of arrays and array rows\r\n            if (currentChar() === \"{\") {\r\n                if (token.length > 0) {\r\n                    // not expected\r\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\r\n                    token = \"\";\r\n                }\r\n                tokenStack.push(tokens.add(\"ARRAY\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\r\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            if (currentChar() === \";\") {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.addRef(tokenStack.pop());\r\n                tokens.add(\",\", TOK_TYPE_ARGUMENT);\r\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            if (currentChar() === \"}\") {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.addRef(tokenStack.pop(\"ARRAYROWSTOP\"));\r\n                tokens.addRef(tokenStack.pop(\"ARRAYSTOP\"));\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // trim white-space\r\n            if (currentChar() === \" \") {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.add(\"\", TOK_TYPE_WSPACE);\r\n                offset += 1;\r\n                while ((currentChar() === \" \") && (!EOF())) {\r\n                    offset += 1;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // multi-character comparators\r\n            if ((\",>=,<=,<>,\").indexOf(\",\" + doubleChar() + \",\") !== -1) {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.add(doubleChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_LOGICAL);\r\n                offset += 2;\r\n                continue;\r\n            }\r\n\r\n            // standard infix operators\r\n            if ((\"+-*/^&=><\").indexOf(currentChar()) !== -1) {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.add(currentChar(), TOK_TYPE_OP_IN);\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // standard postfix operators\r\n            if ((\"%\").indexOf(currentChar()) !== -1) {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.add(currentChar(), TOK_TYPE_OP_POST);\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // start subexpression or function\r\n            if (currentChar() === \"(\") {\r\n                if (token.length > 0) {\r\n                    tokenStack.push(tokens.add(token, TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\r\n                    token = \"\";\r\n                } else {\r\n                    tokenStack.push(tokens.add(\"\", TOK_TYPE_SUBEXPR, TOK_SUBTYPE_START));\r\n                }\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // function, subexpression, array parameters\r\n            if (currentChar() === \",\") {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                if (tokenStack.type() !== TOK_TYPE_FUNCTION) {\r\n                    tokens.add(currentChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_UNION);\r\n                } else {\r\n                    tokens.add(currentChar(), TOK_TYPE_ARGUMENT);\r\n                }\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // stop subexpression\r\n            if (currentChar() === \")\") {\r\n                if (token.length > 0) {\r\n                    tokens.add(token, TOK_TYPE_OPERAND);\r\n                    token = \"\";\r\n                }\r\n                tokens.addRef(tokenStack.pop());\r\n                offset += 1;\r\n                continue;\r\n            }\r\n\r\n            // token accumulation\r\n            token += currentChar();\r\n            offset += 1;\r\n\r\n        }\r\n\r\n        // dump remaining accumulation\r\n        if (token.length > 0) {\r\n            tokens.add(token, TOK_TYPE_OPERAND);\r\n        }\r\n\r\n        // move all tokens to a new collection, excluding all unnecessary white-space tokens\r\n        var tokens2 = new F_tokens();\r\n\r\n        while (tokens.moveNext()) {\r\n\r\n            token = tokens.current();\r\n\r\n            if (token.type.toString() === TOK_TYPE_WSPACE) {\r\n                var doAddToken = (tokens.BOF()) || (tokens.EOF());\r\n                //if ((tokens.BOF()) || (tokens.EOF())) {}\r\n                doAddToken = doAddToken && (((tokens.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens.previous().type.toString() === TOK_TYPE_OPERAND));\r\n                //else if (!(\r\n                //       ((tokens.previous().type === TOK_TYPE_FUNCTION) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \r\n                //\t|| ((tokens.previous().type == TOK_TYPE_SUBEXPR) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \r\n                //\t|| (tokens.previous().type == TOK_TYPE_OPERAND))) \r\n                //  {}\r\n                doAddToken = doAddToken && (((tokens.next().type.toString() === TOK_TYPE_FUNCTION) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || ((tokens.next().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || (tokens.next().type.toString() === TOK_TYPE_OPERAND));\r\n                //else if (!(\r\n                //\t((tokens.next().type == TOK_TYPE_FUNCTION) && (tokens.next().subtype == TOK_SUBTYPE_START)) \r\n                //\t|| ((tokens.next().type == TOK_TYPE_SUBEXPR) && (tokens.next().subtype == TOK_SUBTYPE_START)) \r\n                //\t|| (tokens.next().type == TOK_TYPE_OPERAND))) \r\n                //\t{} \r\n                //else { tokens2.add(token.value, TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT)};\r\n                if (doAddToken) {\r\n                    tokens2.add(token.value.toString(), TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            tokens2.addRef(token);\r\n\r\n        }\r\n\r\n        // switch infix \"-\" operator to prefix when appropriate, switch infix \"+\" operator to noop when appropriate, identify operand \r\n        // and infix-operator subtypes, pull \"@\" from in front of function names\r\n        while (tokens2.moveNext()) {\r\n\r\n            token = tokens2.current();\r\n\r\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"-\")) {\r\n                if (tokens2.BOF()) {\r\n                    token.type = TOK_TYPE_OP_PRE.toString();\r\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\r\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\r\n                } else {\r\n                    token.type = TOK_TYPE_OP_PRE.toString();\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"+\")) {\r\n                if (tokens2.BOF()) {\r\n                    token.type = TOK_TYPE_NOOP.toString();\r\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\r\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\r\n                } else {\r\n                    token.type = TOK_TYPE_NOOP.toString();\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.subtype.length === 0)) {\r\n                if ((\"<>=\").indexOf(token.value.substr(0, 1)) !== -1) {\r\n                    token.subtype = TOK_SUBTYPE_LOGICAL.toString();\r\n                } else if (token.value.toString() === \"&\") {\r\n                    token.subtype = TOK_SUBTYPE_CONCAT.toString();\r\n                } else {\r\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if ((token.type.toString() === TOK_TYPE_OPERAND) && (token.subtype.length === 0)) {\r\n                if (isNaN(parseFloat(token.value))) {\r\n                    if ((token.value.toString() === 'TRUE') || (token.value.toString() === 'FALSE')) {\r\n                        token.subtype = TOK_SUBTYPE_LOGICAL.toString();\r\n                    } else {\r\n                        token.subtype = TOK_SUBTYPE_RANGE.toString();\r\n                    }\r\n                } else {\r\n                    token.subtype = TOK_SUBTYPE_NUMBER.toString();\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (token.type.toString() === TOK_TYPE_FUNCTION) {\r\n                if (token.value.substr(0, 1) === \"@\") {\r\n                    token.value = token.value.substr(1).toString();\r\n                }\r\n                continue;\r\n            }\r\n\r\n        }\r\n\r\n        tokens2.reset();\r\n\r\n        // move all tokens to a new collection, excluding all noops\r\n        tokens = new F_tokens();\r\n\r\n        while (tokens2.moveNext()) {\r\n            if (tokens2.current().type.toString() !== TOK_TYPE_NOOP) {\r\n                tokens.addRef(tokens2.current());\r\n            }\r\n        }\r\n\r\n        tokens.reset();\r\n\r\n        return tokens;\r\n    }\r\n\r\n\r\n    var parseFormula = excelFormulaUtilities.parseFormula = function (inputID, outputID) {\r\n\r\n\r\n            var indentCount = 0;\r\n\r\n            var indent = function () {\r\n                    var s = \"|\",\r\n                        i = 0;\r\n                    for (; i < indentCount; i += 1) {\r\n                        s += \"&nbsp;&nbsp;&nbsp;|\";\r\n                    }\r\n                    return s;\r\n                };\r\n\r\n            var formulaControl = document.getElementById(inputID);\r\n            var formula = formulaControl.value;\r\n\r\n            var tokens = getTokens(formula);\r\n\r\n            var tokensHtml = \"\";\r\n\r\n            tokensHtml += \"<table cellspacing='0' style='border-top: 1px #cecece solid; margin-top: 5px; margin-bottom: 5px'>\";\r\n            tokensHtml += \"<tr>\";\r\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 50px'>index</td>\";\r\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>type</td>\";\r\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>subtype</td>\";\r\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 150px'>token</td>\";\r\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 300px'>token tree</td></tr>\";\r\n\r\n            while (tokens.moveNext()) {\r\n\r\n                var token = tokens.current();\r\n\r\n                if (token.subtype === TOK_SUBTYPE_STOP) {\r\n                    indentCount -= ((indentCount > 0) ? 1 : 0);\r\n                }\r\n\r\n                tokensHtml += \"<tr>\";\r\n\r\n                tokensHtml += \"<td class='token'>\" + (tokens.index + 1) + \"</td>\";\r\n\r\n                tokensHtml += \"<td class='token'>\" + token.type + \"</td>\";\r\n                tokensHtml += \"<td class='token'>\" + ((token.subtype.length === 0) ? \"&nbsp;\" : token.subtype.toString()) + \"</td>\";\r\n                tokensHtml += \"<td class='token'>\" + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\r\n                tokensHtml += \"<td class='token'>\" + indent() + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\r\n\r\n                tokensHtml += \"</tr>\";\r\n\r\n                if (token.subtype === TOK_SUBTYPE_START) {\r\n                    indentCount += 1;\r\n                }\r\n\r\n            }\r\n\r\n            tokensHtml += \"</table>\";\r\n\r\n            document.getElementById(outputID).innerHTML = tokensHtml;\r\n\r\n            formulaControl.select();\r\n            formulaControl.focus();\r\n\r\n        };\r\n\r\n    var applyTokenTemplate = function (token, options, indent, lineBreak, override) {\r\n\r\n            var indt = indent;\r\n\r\n            var replaceTokenTmpl = function (inStr) {\r\n                    return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\r\n                };\r\n\r\n            var tokenString = \"\";\r\n\r\n            if(token.subtype === \"text\" || token.type === \"text\") {\r\n                tokenString = token.value.toString();\r\n            } else {\r\n                tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\r\n            }\r\n\r\n            if (typeof override === 'function') {\r\n                var returnVal = override(tokenString, token, indent, lineBreak);\r\n                \r\n                tokenString = returnVal.tokenString;\r\n\r\n                if (!returnVal.useTemplate) {\r\n                    return tokenString;\r\n                }\r\n            }\r\n\r\n            switch (token.type) {\r\n\r\n            case \"function\":\r\n                //-----------------FUNCTION------------------\r\n                switch (token.value) {\r\n                case \"ARRAY\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArray), tokenString, indt, lineBreak);\r\n                    break;\r\n                case \"ARRAYROW\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArrayRow), tokenString, indt, lineBreak);\r\n                    break;\r\n                default:\r\n                    if (token.subtype.toString() === \"start\") {\r\n                        tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStart), tokenString, indt, lineBreak);\r\n                    } else {\r\n                        tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStop), tokenString, indt, lineBreak);\r\n                    }\r\n                    break;\r\n                }\r\n                break;\r\n            case \"operand\":\r\n                //-----------------OPERAND------------------\r\n                switch (token.subtype.toString()) {\r\n                case \"error\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandError), tokenString, indt, lineBreak);\r\n                    break;\r\n                case \"range\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandRange), tokenString, indt, lineBreak);\r\n                    break;\r\n                case \"number\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandNumber), tokenString, indt, lineBreak);\r\n                    break;\r\n                case \"text\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandText), tokenString, indt, lineBreak);\r\n                    break;\r\n                case \"argument\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\r\n                    break;\r\n                default:\r\n                    break;\r\n                }\r\n                break;\r\n\t\t\tcase \"operator-infix\":\r\n\t\t\t\tcase \"logical\":\r\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandLogical), tokenString, indt, lineBreak);\r\n                    break;\r\n            case \"argument\":\r\n                tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\r\n                break;\r\n\t\t\tcase \"subexpression\":\r\n\t\t\t\tif (token.subtype.toString() === \"start\") {\r\n\t\t\t\t\ttokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStart), tokenString, indt, lineBreak);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStop), tokenString, indt, lineBreak);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n            default:\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n            return tokenString;\r\n        };\r\n\r\n    /**\r\n     *\r\n     * @memberof excelFormulaUtilities.parser\r\n     * @function\r\n     * @param {string} formula\r\n     * @param {object} options optional param\r\n     *<pre>\r\n     *   TEMPLATE VALUES \r\n     *  {{autoindent}} - apply auto indent based on current tree level\r\n     *  {{token}} - the named token such as FUNCTION_NAME or \"string\"\r\n     *  {{autolinebreak}} - apply linbreak automaticly. tests for next element only at this point\r\n\t *\r\n     * Options include:\r\n     *  tmplFunctionStart           - template for the start of a function, the {{token}} will contain the name of the function.\r\n     *  tmplFunctionStop            - template for when the end of a function has been reached.\r\n     *  tmplOperandError            - template for errors.\r\n     *  tmplOperandRange            - template for ranges and variable names.\r\n     *  tmplOperandLogical          - template for logical operators such as + - = ...\r\n     *  tmplOperandNumber           - template for numbers.\r\n     *  tmplOperandText             - template for text/strings.\r\n     *  tmplArgument\t\t\t\t- template for argument seperators such as ,.\r\n     *  tmplFunctionStartArray      - template for the start of an array.\r\n     *  tmplFunctionStartArrayRow   - template for the start of an array row.\r\n     *  tmplFunctionStopArrayRow    - template for the end of an array row.\r\n     *  tmplFunctionStopArray       - template for the end of an array.\r\n\t *  tmplSubexpressionStart      - template for the sub expresson start\r\n\t *  tmplSubexpressionStop       - template for the sub expresson stop\r\n     *  tmplIndentTab               - template for the tab char.\r\n     *  tmplIndentSpace             - template for space char.\r\n     *  autoLineBreak               - when rendering line breaks automaticly which types should it break on. \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\"\r\n     *  newLine                     - used for the {{autolinebreak}} replacement as well as some string parsing. if this is not set correctly you may get undesired results. usually \\n for text or <br /> for html\r\n\t *  trim: true                  - trim the output.\r\n     *\tcustomTokenRender: null     - this is a call back to a custom token function. your call back should look like\r\n     *                                EXAMPLE:\r\n     *                                 \r\n     *                                    customTokenRender: function(tokenString, token, indent, linbreak){\r\n     *                                        var outstr = token,\r\n     *                                            useTemplate = true;\r\n     *                                        // In the return object \"useTemplate\" tells formatFormula() \r\n     *                                        // weather or not to apply the template to what your return from the \"tokenString\".\r\n     *                                        return {tokenString: outstr, useTemplate: useTemplate}; \r\n     *                                    }\r\n     *                                    \r\n     *</pre>\r\n     * @returns {string}\r\n     */\r\n    var formatFormula = excelFormulaUtilities.formatFormula = function (formula, options) {\r\n            var isFirstToken = true,\r\n                defaultOptions = {\r\n                    tmplFunctionStart: '{{autoindent}}{{token}}\\n{{autoindent}}(\\n',\r\n                    tmplFunctionStop: '\\n{{autoindent}}{{token}})',\r\n                    tmplOperandError: '{{token}}',\r\n                    tmplOperandRange: '{{autoindent}}{{token}}',\r\n                    tmplOperandLogical: ' {{token}}{{autolinebreak}}',\r\n                    tmplOperandNumber: '{{autoindent}}{{token}}',\r\n                    tmplOperandText: '{{autoindent}}\"{{token}}\"',\r\n                    tmplArgument: '{{token}}\\n',\r\n                    tmplFunctionStartArray: '',\r\n                    tmplFunctionStartArrayRow: '{',\r\n                    tmplFunctionStopArrayRow: '}',\r\n                    tmplFunctionStopArray: '',\r\n\t\t\t\t\ttmplSubexpressionStart: '{{autoindent}}(',\r\n\t\t\t\t\ttmplSubexpressionStop: ' )',\r\n                    tmplIndentTab: '\\t',\r\n                    tmplIndentSpace: ' ',\r\n                    autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\r\n\t\t\t\t\tnewLine: '\\n',\r\n                    trim: true,\r\n                    customTokenRender: null\r\n                };\r\n\r\n            if (options) {\r\n                options = core.extend(true, defaultOptions, options);\r\n            } else {\r\n                options = defaultOptions;\r\n            }\r\n\r\n            var indentCount = 0;\r\n\r\n            var indent = function () {\r\n                    var s = \"\",\r\n                        i = 0;\r\n\t\t\t\t\t\r\n                    for (; i < indentCount; i += 1) {\r\n                        s += options.tmplIndentTab;\r\n                    }\r\n                    return s;\r\n                };\r\n\r\n            var tokens = getTokens(formula);\r\n\r\n            var outputFormula = \"\";\r\n\r\n            var autoBreakArray = options.autoLineBreak.replace(/\\s/gi, \"\").split(\"|\");\r\n\r\n            //Tokens\r\n            var isNewLine = true;\r\n\r\n            var testAutoBreak = function (nextToken) {\r\n                    var i = 0;\r\n                    for (; i < autoBreakArray.length; i += 1) {\r\n                        if (nextToken !== null && typeof nextToken !== 'undefined' && (types[autoBreakArray[i]] === nextToken.type.toString() || types[autoBreakArray[i]] === nextToken.subtype.toString())) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n            while (tokens.moveNext()) {\r\n\r\n                var token = tokens.current();\r\n                var nextToken = tokens.next();\r\n\r\n                if (token.subtype.toString() === TOK_SUBTYPE_STOP) {\r\n                    indentCount -= ((indentCount > 0) ? 1 : 0);\r\n                }\r\n\t\t\t\t\r\n\t\t\t\tvar matchBeginNewline = new RegExp('^' + options.newLine, ''),\r\n\t\t\t\t\tmatchEndNewLine = new RegExp(options.newLine + '$', ''),\r\n\t\t\t\t\tautoBreak = testAutoBreak(nextToken),\r\n\t\t\t\t\tautoIndent = isNewLine,\r\n\t\t\t\t\tindt = autoIndent ? indent() : options.tmplIndentSpace,\r\n\t\t\t\t\tlineBreak = autoBreak ? options.newLine : \"\";\r\n\r\n                outputFormula += applyTokenTemplate(token, options, indt, lineBreak, options.customTokenRender);\r\n\r\n                if (token.subtype.toString() === TOK_SUBTYPE_START) {\r\n                    indentCount += 1;\r\n\r\n                }\r\n\t\t\t\t\r\n                isNewLine = autoBreak || matchEndNewLine.test(outputFormula);\r\n                isFirstToken = false;\r\n            }\r\n\r\n            return options.trim ? trim(outputFormula) : outputFormula;\r\n        };\r\n\t/**\r\n     * This function calls {@link excelFormulaUtilities.parser.formatFormula}\r\n\t *\r\n     * @memberof excelFormulaUtilities.parser\r\n     * @function\r\n     * @param {string} formula\r\n     * @param {object} options optional param\r\n\t */\r\n\tvar formatFormulaHTML = excelFormulaUtilities.formatFormulaHTML = function(formula){\r\n\t\t\t\tvar options = {\r\n                    tmplFunctionStart: '{{autoindent}}<span class=\"function\">{{token}}</span><br />{{autoindent}}<span class=\"function_start\">(</span><br />',\r\n                    tmplFunctionStop: '<br />{{autoindent}}{{token}}<span class=\"function_stop\">)</span>',\r\n                    tmplOperandError: '{{token}}',\r\n                    tmplOperandRange: '{{autoindent}}{{token}}',\r\n                    tmplOperandLogical: ' {{token}}{{autolinebreak}}',\r\n                    tmplOperandNumber: '{{autoindent}}{{token}}',\r\n                    tmplOperandText: '{{autoindent}}<span class=\"quote_mark\">\"</span><span class=\"text\">{{token}}</span><span class=\"quote_mark\">\"</span>',\r\n                    tmplArgument: '{{token}}<br />',\r\n                    tmplFunctionStartArray: '',\r\n                    tmplFunctionStartArrayRow: '{',\r\n                    tmplFunctionStopArrayRow: '}',\r\n                    tmplFunctionStopArray: '',\r\n\t\t\t\t\ttmplSubexpressionStart: '{{autoindent}}(',\r\n\t\t\t\t\ttmplSubexpressionStop: ' )',\r\n                    tmplIndentTab: '<span class=\"tabs\">&nbsp;&nbsp;&nbsp;&nbsp;</span>',\r\n                    tmplIndentSpace: '&nbsp;',\r\n\t\t\t\t\tnewLine: '<br />',\r\n                    autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\r\n                    trim: true,\r\n                    customTokenRender: null\r\n                };\r\n\t\t\t\t\r\n\t\t\t\treturn formatFormula(formula, options);\r\n\t}\r\n\t\t\r\n    /**\r\n     *\r\n     * @memberof excelFormulaUtilities.convert\r\n     * @function\r\n     * @param {string} formula\r\n     * @returns {string}\r\n     */\r\n    var formula2CSharp = excelFormulaUtilities.formula2CSharp = function (formula) {\r\n\r\n            //Custom callback to format as c#\r\n            var functionStack = [];\r\n\r\n            var tokRender = function (tokenStr, token, indent, linbreak) {\r\n                    var outstr = \"\",\r\n                        /*tokenString = (token.value.length === 0) ? \"\" : token.value.toString(),*/\r\n                        tokenString = tokenStr,\r\n                        directConversionMap = {\r\n                            \"=\": \"==\",\r\n                            \"<>\": \"!=\",\r\n                            \"MIN\": \"Math.Min\",\r\n                            \"MAX\": \"Math.Max\",\r\n                            \"ABS\": \"Math.ABS\",\r\n\t\t\t\t\t\t\t\"SUM\": \"\",\r\n\t\t\t\t\t\t\t\"IF\": \"\",\r\n\t\t\t\t\t\t\t\"&\" : \"+\"\r\n                        },\r\n                        currentFunctionOnStack = functionStack[functionStack.length - 1],\r\n                        useTemplate = false;\r\n\r\n                    switch (token.type.toString()) {\r\n\r\n                    case TOK_TYPE_FUNCTION:\r\n\r\n                        switch (token.subtype) {\r\n\r\n                        case TOK_SUBTYPE_START:\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfunctionStack.push({\r\n\t\t\t\t\t\t\t\tname: tokenString,\r\n\t\t\t\t\t\t\t\targumentNumber: 0\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\toutstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\r\n\t\t\t\t\t\t\tuseTemplate = true;\r\n\t\t\t\t\t\t\t\r\n                            break;\r\n                        case TOK_SUBTYPE_STOP:\r\n\r\n                            useTemplate = true;\r\n\t\t\t\t\t\t\tswitch (currentFunctionOnStack.name.toLowerCase()){\r\n                            case \"if\":\r\n                                outstr = \")\";\r\n                                useTemplate = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n                            default:\r\n                                outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\r\n\t\t\t\t\t\t\t\tbreak\r\n                            }\r\n                            functionStack.pop();\r\n                            break;\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case TOK_TYPE_ARGUMENT:\r\n                        switch (currentFunctionOnStack.name.toLowerCase()){\r\n\t\t\t\t\t\tcase \"if\":\r\n                            switch (currentFunctionOnStack.argumentNumber) {\r\n                            case 0:\r\n                                outstr = \"?\";\r\n                                break;\r\n                            case 1:\r\n                                outstr = \":\";\r\n                                break;\r\n                            }\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"sum\":\r\n\t\t\t\t\t\t\toutstr = \"+\";\r\n\t\t\t\t\t\t\tbreak;\r\n                        default:\r\n                            outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\r\n                            useTemplate = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n                        currentFunctionOnStack.argumentNumber += 1;\r\n\r\n                        break;\r\n                    \r\n                    case TOK_SUBTYPE_RANGE:\r\n                        \r\n                        switch (currentFunctionOnStack.name.toLowerCase()){\r\n                            // If in the sum function break aout cell names and add\r\n                            case \"sum\":\r\n                                console.log(tokenString);\r\n                                //TODO loop through and add ranges together\r\n                                break;\r\n                            // By Default return an array containing all cell names in array\r\n                            default:\r\n                                //TODO create array for ranges\r\n                                break;\r\n                        }\r\n                        \r\n                        break;\r\n\r\n                    default:\r\n                        outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\r\n                        useTemplate = true;\r\n                        break;\r\n                    }\r\n\r\n                    return {\r\n                        tokenString: outstr,\r\n                        useTemplate: useTemplate\r\n                    };\r\n                };\r\n\r\n            var cSharpOutput = formatFormula(\r\n            formula, {\r\n                tmplFunctionStart: '{{token}}(',\r\n                tmplFunctionStop: '{{token}})',\r\n                tmplOperandError: '{{token}}',\r\n                tmplOperandRange: '{{token}}',\r\n                tmplOperandLogical: '{{token}}',\r\n                tmplOperandNumber: '{{token}}',\r\n                tmplOperandText: '\"{{token}}\"',\r\n                tmplArgument: '{{token}}',\r\n                tmplFunctionStartArray: \"\",\r\n                tmplFunctionStartArrayRow: \"{\",\r\n                tmplFunctionStopArrayRow: \"}\",\r\n                tmplFunctionStopArray: \"\",\r\n\t\t\t\ttmplSubexpressionStart: \"(\",\r\n\t\t\t\ttmplSubexpressionStop: \")\",\r\n                tmplIndentTab: \"\\t\",\r\n                tmplIndentSpace: \" \",\r\n                autoLineBreak: \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\",\r\n                trim: true,\r\n                customTokenRender: tokRender\r\n            });\r\n            return cSharpOutput;\r\n        };\r\n\t\r\n\t/**\r\n     * Both the csharp and javascript are the same when converted, this is just an alias for convert2CSharp. there are some subtle differences such as == vrs ===, this will be addressed in a later version.\r\n     * @memberof excelFormulaUtilities.convert\r\n     * @function\r\n     * @param {string} formula\r\n     * @returns {string}\r\n     */\r\n\tvar formula2JavaScript = excelFormulaUtilities.formula2JavaScript = function (formula) {\r\n\t\t\treturn formula2CSharp(formula);\r\n\t\t}\r\n}());"]],"start1":0,"start2":0,"length1":0,"length2":41527}]],"length":41527}
