{"ts":1349354094204,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * excelFormulaUtilitiesJS\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\n *\n * Copyright 2011, Josh Bennett\n * licensed under the MIT license.\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\n *\n * Some functionality based off of the jquery core lib\n * Copyright 2011, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\n */\n \n(function () {\n\n\n    var excelFormulaUtilities = window.excelFormulaUtilities = window.excelFormulaUtilities || {};\n    var core = window.excelFormulaUtilities.core = {};\n\twindow.excelFormulaUtilities.string = window.excelFormulaUtilities.string || {};\n\t\n\t/**\n\t* Simple/quick string formater. This will take an input string and apply n number of arguments to it.\n\t*\n\t* <b>example:</b><br />\n\t* <code>\n\t* <pre>\n\t*\tvar foo = excelFormulaUtilities.core.formatStr(\"{0}\", \"foo\"); // foo will be set to \"foo\"\n\t*\tvar fooBar = excelFormulaUtilities.core.formatStr(\"{0} {1}\", \"foo\", \"bar\"); // fooBar will be set to \"fooBar\"\n\t*\tvar error = excelFormulaUtilities.core.formatStr(\"{1}\", \"error\"); // will throw an index out of range error since only 1 extra argument was passed, which would be index 0.\n\t* </pre>\n\t* </code>\n\t*\n    * @memberOf window.excelFormulaUtilities.core\n\t* @function\n    * @param {String} inStr \n    **/\n\tvar formatStr = window.excelFormulaUtilities.string.formatStr = function(inStr) {\n\t\t\tvar formattedStr = inStr;\n\t\t\tvar argIndex = 1;\n\t\t\tfor (; argIndex < arguments.length; argIndex++) {\n\t\t\t\tvar replaceIndex = (argIndex - 1);\n\t\t\t\tvar replaceRegex = new RegExp(\"\\\\{{1}\" + replaceIndex.toString() + \"{1}\\\\}{1}\", \"g\");\n\t\t\t\tformattedStr = formattedStr.replace(replaceRegex, arguments[argIndex]);\n\t\t\t}\n\t\t\treturn formattedStr;\n\t\t};\n    \n    var trim = window.excelFormulaUtilities.string.trim = function(inStr){\n\t\t\treturn inStr.replace(/^\\s|\\s$/, \"\");\n\t\t};\n\t\n\tvar trimHTML = window.excelFormulaUtilities.string.trim = function(inStr){\n\t\t\treturn inStr.replace(/^(?:\\s|&nbsp;|<\\s*br\\s*\\/*\\s*>)*|(?:\\s|&nbsp;|<\\s*br\\s*\\/*\\s*>)*$/, \"\");\n\t\t};\n\n\t//Quick and dirty type checks\n\t/**\n\t* @param {object} obj\n\t* @returns {boolean}\n\t* @memberOf window.excelFormulaUtilities.core\n\t*/\n\tvar isFunction = core.isFunction = function (obj) {\n\t\treturn (typeof obj) === \"function\";\n\t};\n\n\t/**\n\t* @param {object} obj\n\t* @returns {boolean}\n\t* @memberOf window.excelFormulaUtilities.core\n\t*/\n\tvar isArray = core.isArray = function (obj) {\n\t\treturn (typeof obj) === \"object\" && obj.length;\n\t};\n\n\t/**\n\t* @param {object} obj\n\t* @returns {boolean}\n\t* @memberOf window.excelFormulaUtilities.core\n\t*/\n\tvar isWindow = core.isWindow = function () {\n\t\treturn obj && typeof obj === \"object\" && \"setInterval\" in obj;\n\t}; /*----The functionality below has based off of the jQuery core library----*/\n\n\t/**\n\t* Check if the object is a plain object or not. This has been pulled from the jQuery core and modified slightly.\n\t* @param {object} obj\n\t* @returns {boolean} returns weather the object is a plain object or not.\n\t* @memberOf window.excelFormulaUtilities.core\n\t*/\n\tvar isPlainObject = core.isPlainObject = function (obj) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif (!obj || typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\n\t\t\treturn false;\n\t\t}\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnProperty.call(obj, \"constructor\") && !hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t\t\treturn false;\n\t\t}\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) { }\n\t\treturn key === undefined || hasOwnProperty.call(obj, key);\n\t};\n\n\t/**\n\t* This has been pulled from the jQuery core and modified slightly. see http://api.jquery.com/jQuery.extend/\n\t* @param {object} target\n\t* @param {object} object add one or more object to extend the target.\n\t* @returns {object} returns the extended object.\n\t* @memberOf window.excelFormulaUtilities.core\n\t*/\n\tvar extend = core.extend = function () {\n\t\tvar options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === \"boolean\") {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t}\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif (typeof target !== \"object\" && !isFunction(target)) {\n\t\t\ttarget = {};\n\t\t}\n\t\t// extend jQuery itself if only one argument is passed\n\t\tif (length === i) {\n\t\t\ttarget = this;\n\t\t\t--i;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ((options = arguments[i]) != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = core.extend(deep, clone, copy);\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return the modified object\n\t\treturn target;\n\t}; /*----end of jquery functionality----*/\n\n\t\n}());\n\n/*\n * excelFormulaUtilitiesJS\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\n *\n * Copyright 2011, Josh Bennett\n * licensed under the MIT license.\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\n *\n * Some functionality based off of the jquery core lib\n * Copyright 2011, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\n */\n(function () {\n    var excelFormulaUtilities = window.excelFormulaUtilities = window.excelFormulaUtilities || {},\n        core = window.excelFormulaUtilities.core,\n        formatStr = window.excelFormulaUtilities.string.formatStr,\n        trim = window.excelFormulaUtilities.string.trim,\n\n        types = {},\n        TOK_TYPE_NOOP = types.TOK_TYPE_NOOP = \"noop\",\n        TOK_TYPE_OPERAND = types.TOK_TYPE_OPERAND = \"operand\",\n        TOK_TYPE_FUNCTION = types.TOK_TYPE_FUNCTION = \"function\",\n        TOK_TYPE_SUBEXPR = types.TOK_TYPE_SUBEXPR = \"subexpression\",\n        TOK_TYPE_ARGUMENT = types.TOK_TYPE_ARGUMENT = \"argument\",\n        TOK_TYPE_OP_PRE = types.TOK_TYPE_OP_PRE = \"operator-prefix\",\n        TOK_TYPE_OP_IN = types.TOK_TYPE_OP_IN = \"operator-infix\",\n        TOK_TYPE_OP_POST = types.TOK_TYPE_OP_POST = \"operator-postfix\",\n        TOK_TYPE_WSPACE = types.TOK_TYPE_WSPACE = \"white-space\",\n        TOK_TYPE_UNKNOWN = types.TOK_TYPE_UNKNOWN = \"unknown\",\n\n        TOK_SUBTYPE_START = types.TOK_SUBTYPE_START = \"start\",\n        TOK_SUBTYPE_STOP = types.TOK_SUBTYPE_STOP = \"stop\",\n\n        TOK_SUBTYPE_TEXT = types.TOK_SUBTYPE_TEXT = \"text\",\n        TOK_SUBTYPE_NUMBER = types.TOK_SUBTYPE_NUMBER = \"number\",\n        TOK_SUBTYPE_LOGICAL = types.TOK_SUBTYPE_LOGICAL = \"logical\",\n        TOK_SUBTYPE_ERROR = types.TOK_SUBTYPE_ERROR = \"error\",\n        TOK_SUBTYPE_RANGE = types.TOK_SUBTYPE_RANGE = \"range\",\n\n        TOK_SUBTYPE_MATH = types.TOK_SUBTYPE_MATH = \"math\",\n        TOK_SUBTYPE_CONCAT = types.TOK_SUBTYPE_CONCAT = \"concatenate\",\n        TOK_SUBTYPE_INTERSECT = types.TOK_SUBTYPE_INTERSECT = \"intersect\",\n        TOK_SUBTYPE_UNION = types.TOK_SUBTYPE_UNION = \"union\";\n\n    /**\n     * @class\n     */\n\n    function F_token(value, type, subtype) {\n        this.value = value;\n        this.type = type;\n        this.subtype = subtype;\n    }\n\n    /**\n     * @class\n     */\n\n    function F_tokens() {\n\n        this.items = [];\n\n        this.add = function (value, type, subtype) {\n            if (!subtype) {\n                subtype = \"\";\n            }\n            var token = new F_token(value, type, subtype);\n            this.addRef(token);\n            return token;\n        };\n        this.addRef = function (token) {\n            this.items.push(token);\n        };\n\n        this.index = -1;\n        this.reset = function () {\n            this.index = -1;\n        };\n        this.BOF = function () {\n            return (this.index <= 0);\n        };\n        this.EOF = function () {\n            return (this.index >= (this.items.length - 1));\n        };\n        this.moveNext = function () {\n            if (this.EOF()) {\n                return false;\n            }\n            this.index += 1;\n            return true;\n        };\n        this.current = function () {\n            if (this.index === -1) {\n                return null;\n            }\n            return (this.items[this.index]);\n        };\n        this.next = function () {\n            if (this.EOF()) {\n                return null;\n            }\n            return (this.items[this.index + 1]);\n        };\n        this.previous = function () {\n            if (this.index < 1) {\n                return null;\n            }\n            return (this.items[this.index - 1]);\n        };\n\n    }\n\n    function F_tokenStack() {\n\n        this.items = [];\n\n        this.push = function (token) {\n            this.items.push(token);\n        };\n        this.pop = function (name) {\n            var token = this.items.pop();\n            return (new F_token(name || \"\", token.type, TOK_SUBTYPE_STOP));\n        };\n\n        this.token = function () {\n            return ((this.items.length > 0) ? this.items[this.items.length - 1] : null);\n        };\n        this.value = function () {\n            return ((this.token()) ? this.token().value.toString() : \"\");\n        };\n        this.type = function () {\n            return ((this.token()) ? this.token().type.toString() : \"\");\n        };\n        this.subtype = function () {\n            return ((this.token()) ? this.token().subtype.toString() : \"\");\n        };\n\n    }\n\n    function getTokens(formula) {\n\n        var tokens = new F_tokens(),\n            tokenStack = new F_tokenStack(),\n\n            offset = 0,\n\n            currentChar = function () {\n                return formula.substr(offset, 1);\n            },\n            doubleChar = function () {\n                return formula.substr(offset, 2);\n            },\n            nextChar = function () {\n                return formula.substr(offset + 1, 1);\n            },\n            EOF = function () {\n                return (offset >= formula.length);\n            },\n\n            token = \"\",\n\n            inString = false,\n            inPath = false,\n            inRange = false,\n            inError = false,\n            regexSN = /^[1-9]{1}(\\.[0-9]+)?E{1}$/;\n\n        while (formula.length > 0) {\n            if (formula.substr(0, 1) === \" \") {\n                formula = formula.substr(1);\n            } else {\n                if (formula.substr(0, 1) === \"=\") {\n                    formula = formula.substr(1);\n                }\n                break;\n            }\n        }\n\n\n\n        while (!EOF()) {\n\n            // state-dependent character evaluation (order is important)\n            // double-quoted strings\n            // embeds are doubled\n            // end marks token\n            if (inString) {\n                if (currentChar() === \"\\\"\") {\n                    if (nextChar() === \"\\\"\") {\n                        token += \"\\\"\";\n                        offset += 1;\n                    } else {\n                        inString = false;\n                        tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_TEXT);\n                        token = \"\";\n                    }\n                } else {\n                    token += currentChar();\n                }\n                offset += 1;\n                continue;\n            }\n\n            // single-quoted strings (links)\n            // embeds are double\n            // end does not mark a token\n            if (inPath) {\n                if (currentChar() === \"'\") {\n                    if (nextChar() === \"'\") {\n                        token += \"'\";\n                        offset += 1;\n                    } else {\n                        inPath = false;\n                    }\n                } else {\n                    token += currentChar();\n                }\n                offset += 1;\n                continue;\n            }\n\n            // bracked strings (range offset or linked workbook name)\n            // no embeds (changed to \"()\" by Excel)\n            // end does not mark a token\n            if (inRange) {\n                if (currentChar() === \"]\") {\n                    inRange = false;\n                }\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // error values\n            // end marks a token, determined from absolute list of values\n            if (inError) {\n                token += currentChar();\n                offset += 1;\n                if ((\",#NULL!,#DIV/0!,#VALUE!,#REF!,#NAME?,#NUM!,#N/A,\").indexOf(\",\" + token + \",\") !== -1) {\n                    inError = false;\n                    tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_ERROR);\n                    token = \"\";\n                }\n                continue;\n            }\n\n            // scientific notation check\n            if ((\"+-\").indexOf(currentChar()) !== -1) {\n                if (token.length > 1) {\n                    if (token.match(regexSN)) {\n                        token += currentChar();\n                        offset += 1;\n                        continue;\n                    }\n                }\n            }\n\n            // independent character evaulation (order not important)\n            // establish state-dependent character evaluations\n            if (currentChar() === \"\\\"\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inString = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"'\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inPath = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"[\") {\n                inRange = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"#\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inError = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // mark start and end of arrays and array rows\n            if (currentChar() === \"{\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                tokenStack.push(tokens.add(\"ARRAY\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \";\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop());\n                tokens.add(\",\", TOK_TYPE_ARGUMENT);\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"}\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop(\"ARRAYROWSTOP\"));\n                tokens.addRef(tokenStack.pop(\"ARRAYSTOP\"));\n                offset += 1;\n                continue;\n            }\n\n            // trim white-space\n            if (currentChar() === \" \") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(\"\", TOK_TYPE_WSPACE);\n                offset += 1;\n                while ((currentChar() === \" \") && (!EOF())) {\n                    offset += 1;\n                }\n                continue;\n            }\n\n            // multi-character comparators\n            if ((\",>=,<=,<>,\").indexOf(\",\" + doubleChar() + \",\") !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(doubleChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_LOGICAL);\n                offset += 2;\n                continue;\n            }\n\n            // standard infix operators\n            if ((\"+-*/^&=><\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_IN);\n                offset += 1;\n                continue;\n            }\n\n            // standard postfix operators\n            if ((\"%\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_POST);\n                offset += 1;\n                continue;\n            }\n\n            // start subexpression or function\n            if (currentChar() === \"(\") {\n                if (token.length > 0) {\n                    tokenStack.push(tokens.add(token, TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                    token = \"\";\n                } else {\n                    tokenStack.push(tokens.add(\"\", TOK_TYPE_SUBEXPR, TOK_SUBTYPE_START));\n                }\n                offset += 1;\n                continue;\n            }\n\n            // function, subexpression, array parameters\n            if (currentChar() === \",\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                if (tokenStack.type() !== TOK_TYPE_FUNCTION) {\n                    tokens.add(currentChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_UNION);\n                } else {\n                    tokens.add(currentChar(), TOK_TYPE_ARGUMENT);\n                }\n                offset += 1;\n                continue;\n            }\n\n            // stop subexpression\n            if (currentChar() === \")\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop());\n                offset += 1;\n                continue;\n            }\n\n            // token accumulation\n            token += currentChar();\n            offset += 1;\n\n        }\n\n        // dump remaining accumulation\n        if (token.length > 0) {\n            tokens.add(token, TOK_TYPE_OPERAND);\n        }\n\n        // move all tokens to a new collection, excluding all unnecessary white-space tokens\n        var tokens2 = new F_tokens();\n\n        while (tokens.moveNext()) {\n\n            token = tokens.current();\n\n            if (token.type.toString() === TOK_TYPE_WSPACE) {\n                var doAddToken = (tokens.BOF()) || (tokens.EOF());\n                //if ((tokens.BOF()) || (tokens.EOF())) {}\n                doAddToken = doAddToken && (((tokens.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens.previous().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //\t   ((tokens.previous().type === TOK_TYPE_FUNCTION) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \n                //\t|| ((tokens.previous().type == TOK_TYPE_SUBEXPR) && (tokens.previous().subtype == TOK_SUBTYPE_STOP)) \n                //\t|| (tokens.previous().type == TOK_TYPE_OPERAND))) \n                //  {}\n                doAddToken = doAddToken && (((tokens.next().type.toString() === TOK_TYPE_FUNCTION) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || ((tokens.next().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || (tokens.next().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //\t((tokens.next().type == TOK_TYPE_FUNCTION) && (tokens.next().subtype == TOK_SUBTYPE_START)) \n                //\t|| ((tokens.next().type == TOK_TYPE_SUBEXPR) && (tokens.next().subtype == TOK_SUBTYPE_START)) \n                //\t|| (tokens.next().type == TOK_TYPE_OPERAND))) \n                //\t{} \n                //else { tokens2.add(token.value, TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT)};\n                if (doAddToken) {\n                    tokens2.add(token.value.toString(), TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT);\n                }\n                continue;\n            }\n\n            tokens2.addRef(token);\n\n        }\n\n        // switch infix \"-\" operator to prefix when appropriate, switch infix \"+\" operator to noop when appropriate, identify operand \n        // and infix-operator subtypes, pull \"@\" from in front of function names\n        while (tokens2.moveNext()) {\n\n            token = tokens2.current();\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"-\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"+\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_NOOP.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_NOOP.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.subtype.length === 0)) {\n                if ((\"<>=\").indexOf(token.value.substr(0, 1)) !== -1) {\n                    token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                } else if (token.value.toString() === \"&\") {\n                    token.subtype = TOK_SUBTYPE_CONCAT.toString();\n                } else {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OPERAND) && (token.subtype.length === 0)) {\n                if (isNaN(parseFloat(token.value))) {\n                    if ((token.value.toString() === 'TRUE') || (token.value.toString() === 'FALSE')) {\n                        token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                    } else {\n                        token.subtype = TOK_SUBTYPE_RANGE.toString();\n                    }\n                } else {\n                    token.subtype = TOK_SUBTYPE_NUMBER.toString();\n                }\n\n                continue;\n            }\n\n            if (token.type.toString() === TOK_TYPE_FUNCTION) {\n                if (token.value.substr(0, 1) === \"@\") {\n                    token.value = token.value.substr(1).toString();\n                }\n                continue;\n            }\n\n        }\n\n        tokens2.reset();\n\n        // move all tokens to a new collection, excluding all noops\n        tokens = new F_tokens();\n\n        while (tokens2.moveNext()) {\n            if (tokens2.current().type.toString() !== TOK_TYPE_NOOP) {\n                tokens.addRef(tokens2.current());\n            }\n        }\n\n        tokens.reset();\n\n        return tokens;\n    }\n\n\n    var parseFormula = excelFormulaUtilities.parseFormula = function (inputID, outputID) {\n\n\n            var indentCount = 0;\n\n            var indent = function () {\n                    var s = \"|\",\n                        i = 0;\n                    for (; i < indentCount; i += 1) {\n                        s += \"&nbsp;&nbsp;&nbsp;|\";\n                    }\n                    return s;\n                };\n\n            var formulaControl = document.getElementById(inputID);\n            var formula = formulaControl.value;\n\n            var tokens = getTokens(formula);\n\n            var tokensHtml = \"\";\n\n            tokensHtml += \"<table cellspacing='0' style='border-top: 1px #cecece solid; margin-top: 5px; margin-bottom: 5px'>\";\n            tokensHtml += \"<tr>\";\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 50px'>index</td>\";\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>type</td>\";\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>subtype</td>\";\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 150px'>token</td>\";\n            tokensHtml += \"<td class='token' style='font-weight: bold; width: 300px'>token tree</td></tr>\";\n\n            while (tokens.moveNext()) {\n\n                var token = tokens.current();\n\n                if (token.subtype === TOK_SUBTYPE_STOP) {\n                    indentCount -= ((indentCount > 0) ? 1 : 0);\n                }\n\n                tokensHtml += \"<tr>\";\n\n                tokensHtml += \"<td class='token'>\" + (tokens.index + 1) + \"</td>\";\n\n                tokensHtml += \"<td class='token'>\" + token.type + \"</td>\";\n                tokensHtml += \"<td class='token'>\" + ((token.subtype.length === 0) ? \"&nbsp;\" : token.subtype.toString()) + \"</td>\";\n                tokensHtml += \"<td class='token'>\" + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n                tokensHtml += \"<td class='token'>\" + indent() + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n\n                tokensHtml += \"</tr>\";\n\n                if (token.subtype === TOK_SUBTYPE_START) {\n                    indentCount += 1;\n                }\n\n            }\n\n            tokensHtml += \"</table>\";\n\n            document.getElementById(outputID).innerHTML = tokensHtml;\n\n            formulaControl.select();\n            formulaControl.focus();\n\n        };\n\n    var applyTokenTemplate = function (token, options, indent, lineBreak, override) {\n\n            var indt = indent;\n\n            var replaceTokenTmpl = function (inStr) {\n                    return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\n                };\n\n            var tokenString = \"\";\n\n            if(token.subtype === \"text\" || token.type === \"text\") {\n                tokenString = token.value.toString();\n            } else {\n                tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\n            }\n\n            if (typeof override === 'function') {\n                var returnVal = override(tokenString, token, indent, lineBreak);\n                \n                tokenString = returnVal.tokenString;\n\n                if (!returnVal.useTemplate) {\n                    return tokenString;\n                }\n            }\n\n            switch (token.type) {\n\n            case \"function\":\n                //-----------------FUNCTION------------------\n                switch (token.value) {\n                case \"ARRAY\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArray), tokenString, indt, lineBreak);\n                    break;\n                case \"ARRAYROW\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArrayRow), tokenString, indt, lineBreak);\n                    break;\n                default:\n                    if (token.subtype.toString() === \"start\") {\n                        tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStart), tokenString, indt, lineBreak);\n                    } else {\n                        tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStop), tokenString, indt, lineBreak);\n                    }\n                    break;\n                }\n                break;\n            case \"operand\":\n                //-----------------OPERAND------------------\n                switch (token.subtype.toString()) {\n                case \"error\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandError), tokenString, indt, lineBreak);\n                    break;\n                case \"range\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandRange), tokenString, indt, lineBreak);\n                    break;\n                case \"number\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandNumber), tokenString, indt, lineBreak);\n                    break;\n                case \"text\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandText), tokenString, indt, lineBreak);\n                    break;\n                case \"argument\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n                    break;\n                default:\n                    break;\n                }\n                break;\n\t\t\tcase \"operator-infix\":\n\t\t\t\tcase \"logical\":\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplOperandLogical), tokenString, indt, lineBreak);\n                    break;\n            case \"argument\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n                break;\n\t\t\tcase \"subexpression\":\n\t\t\t\tif (token.subtype.toString() === \"start\") {\n\t\t\t\t\ttokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStart), tokenString, indt, lineBreak);\n\t\t\t\t} else {\n\t\t\t\t\ttokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStop), tokenString, indt, lineBreak);\n\t\t\t\t}\n\t\t\t\tbreak;\n            default:\n\n                break;\n\n            }\n\n\n            return tokenString;\n        };\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n     *<pre>\n     *   TEMPLATE VALUES \n     *  {{autoindent}} - apply auto indent based on current tree level\n     *  {{token}} - the named token such as FUNCTION_NAME or \"string\"\n     *  {{autolinebreak}} - apply linbreak automaticly. tests for next element only at this point\n\t *\n     * Options include:\n     *  tmplFunctionStart           - template for the start of a function, the {{token}} will contain the name of the function.\n     *  tmplFunctionStop            - template for when the end of a function has been reached.\n     *  tmplOperandError            - template for errors.\n     *  tmplOperandRange            - template for ranges and variable names.\n     *  tmplOperandLogical          - template for logical operators such as + - = ...\n     *  tmplOperandNumber           - template for numbers.\n     *  tmplOperandText             - template for text/strings.\n     *  tmplArgument\t\t\t\t- template for argument seperators such as ,.\n     *  tmplFunctionStartArray      - template for the start of an array.\n     *  tmplFunctionStartArrayRow   - template for the start of an array row.\n     *  tmplFunctionStopArrayRow    - template for the end of an array row.\n     *  tmplFunctionStopArray       - template for the end of an array.\n\t *  tmplSubexpressionStart      - template for the sub expresson start\n\t *  tmplSubexpressionStop       - template for the sub expresson stop\n     *  tmplIndentTab               - template for the tab char.\n     *  tmplIndentSpace             - template for space char.\n     *  autoLineBreak               - when rendering line breaks automaticly which types should it break on. \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\"\n     *  newLine                     - used for the {{autolinebreak}} replacement as well as some string parsing. if this is not set correctly you may get undesired results. usually \\n for text or <br /> for html\n\t *  trim: true                  - trim the output.\n     *\tcustomTokenRender: null     - this is a call back to a custom token function. your call back should look like\n     *                                EXAMPLE:\n     *                                 \n     *                                    customTokenRender: function(tokenString, token, indent, linbreak){\n     *                                        var outstr = token,\n     *                                            useTemplate = true;\n     *                                        // In the return object \"useTemplate\" tells formatFormula() \n     *                                        // weather or not to apply the template to what your return from the \"tokenString\".\n     *                                        return {tokenString: outstr, useTemplate: useTemplate}; \n     *                                    }\n     *                                    \n     *</pre>\n     * @returns {string}\n     */\n    var formatFormula = excelFormulaUtilities.formatFormula = function (formula, options) {\n            var isFirstToken = true,\n                defaultOptions = {\n                    tmplFunctionStart: '{{autoindent}}{{token}}\\n{{autoindent}}(\\n',\n                    tmplFunctionStop: '\\n{{autoindent}}{{token}})',\n                    tmplOperandError: '{{token}}',\n                    tmplOperandRange: '{{autoindent}}{{token}}',\n                    tmplOperandLogical: ' {{token}}{{autolinebreak}}',\n                    tmplOperandNumber: '{{autoindent}}{{token}}',\n                    tmplOperandText: '{{autoindent}}\"{{token}}\"',\n                    tmplArgument: '{{token}}\\n',\n                    tmplFunctionStartArray: '',\n                    tmplFunctionStartArrayRow: '{',\n                    tmplFunctionStopArrayRow: '}',\n                    tmplFunctionStopArray: '',\n\t\t\t\t\ttmplSubexpressionStart: '{{autoindent}}(',\n\t\t\t\t\ttmplSubexpressionStop: ' )',\n                    tmplIndentTab: '\\t',\n                    tmplIndentSpace: ' ',\n                    autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n\t\t\t\t\tnewLine: '\\n',\n                    trim: true,\n                    customTokenRender: null\n                };\n\n            if (options) {\n                options = core.extend(true, defaultOptions, options);\n            } else {\n                options = defaultOptions;\n            }\n\n            var indentCount = 0;\n\n            var indent = function () {\n                    var s = \"\",\n                        i = 0;\n\t\t\t\t\t\n                    for (; i < indentCount; i += 1) {\n                        s += options.tmplIndentTab;\n                    }\n                    return s;\n                };\n\n            var tokens = getTokens(formula);\n\n            var outputFormula = \"\";\n\n            var autoBreakArray = options.autoLineBreak.replace(/\\s/gi, \"\").split(\"|\");\n\n            //Tokens\n            var isNewLine = true;\n\n            var testAutoBreak = function (nextToken) {\n                    var i = 0;\n                    for (; i < autoBreakArray.length; i += 1) {\n                        if (nextToken !== null && typeof nextToken !== 'undefined' && (types[autoBreakArray[i]] === nextToken.type.toString() || types[autoBreakArray[i]] === nextToken.subtype.toString())) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n\n            while (tokens.moveNext()) {\n\n                var token = tokens.current();\n                var nextToken = tokens.next();\n\n                if (token.subtype.toString() === TOK_SUBTYPE_STOP) {\n                    indentCount -= ((indentCount > 0) ? 1 : 0);\n                }\n\t\t\t\t\n\t\t\t\tvar matchBeginNewline = new RegExp('^' + options.newLine, ''),\n\t\t\t\t\tmatchEndNewLine = new RegExp(options.newLine + '$', ''),\n\t\t\t\t\tautoBreak = testAutoBreak(nextToken),\n\t\t\t\t\tautoIndent = isNewLine,\n\t\t\t\t\tindt = autoIndent ? indent() : options.tmplIndentSpace,\n\t\t\t\t\tlineBreak = autoBreak ? options.newLine : \"\";\n\n                outputFormula += applyTokenTemplate(token, options, indt, lineBreak, options.customTokenRender);\n\n                if (token.subtype.toString() === TOK_SUBTYPE_START) {\n                    indentCount += 1;\n\n                }\n\t\t\t\t\n                isNewLine = autoBreak || matchEndNewLine.test(outputFormula);\n                isFirstToken = false;\n            }\n\n            return options.trim ? trim(outputFormula) : outputFormula;\n        };\n\t/**\n     * This function calls {@link excelFormulaUtilities.parser.formatFormula}\n\t *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n\t */\n\tvar formatFormulaHTML = excelFormulaUtilities.formatFormulaHTML = function(formula){\n\t\t\t\tvar options = {\n                    tmplFunctionStart: '{{autoindent}}<span class=\"function\">{{token}}</span><br />{{autoindent}}<span class=\"function_start\">(</span><br />',\n                    tmplFunctionStop: '<br />{{autoindent}}{{token}}<span class=\"function_stop\">)</span>',\n                    tmplOperandError: '{{token}}',\n                    tmplOperandRange: '{{autoindent}}{{token}}',\n                    tmplOperandLogical: ' {{token}}{{autolinebreak}}',\n                    tmplOperandNumber: '{{autoindent}}{{token}}',\n                    tmplOperandText: '{{autoindent}}<span class=\"quote_mark\">\"</span><span class=\"text\">{{token}}</span><span class=\"quote_mark\">\"</span>',\n                    tmplArgument: '{{token}}<br />',\n                    tmplFunctionStartArray: '',\n                    tmplFunctionStartArrayRow: '{',\n                    tmplFunctionStopArrayRow: '}',\n                    tmplFunctionStopArray: '',\n\t\t\t\t\ttmplSubexpressionStart: '{{autoindent}}(',\n\t\t\t\t\ttmplSubexpressionStop: ' )',\n                    tmplIndentTab: '<span class=\"tabs\">&nbsp;&nbsp;&nbsp;&nbsp;</span>',\n                    tmplIndentSpace: '&nbsp;',\n\t\t\t\t\tnewLine: '<br />',\n                    autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n                    trim: true,\n                    customTokenRender: null\n                };\n\t\t\t\t\n\t\t\t\treturn formatFormula(formula, options);\n\t}\n\t\t\n    /**\n     *\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2CSharp = excelFormulaUtilities.formula2CSharp = function (formula) {\n\n            //Custom callback to format as c#\n            var functionStack = [];\n\n            var tokRender = function (tokenStr, token, indent, linbreak) {\n                    var outstr = \"\",\n                        /*tokenString = (token.value.length === 0) ? \"\" : token.value.toString(),*/\n                        tokenString = tokenStr,\n                        directConversionMap = {\n                            \"=\": \"==\",\n                            \"<>\": \"!=\",\n                            \"MIN\": \"Math.Min\",\n                            \"MAX\": \"Math.Max\",\n                            \"ABS\": \"Math.ABS\",\n\t\t\t\t\t\t\t\"SUM\": \"\",\n\t\t\t\t\t\t\t\"IF\": \"\",\n\t\t\t\t\t\t\t\"&\" : \"+\"\n                        },\n                        currentFunctionOnStack = functionStack[functionStack.length - 1],\n                        useTemplate = false;\n\n                    switch (token.type.toString()) {\n\n                    case TOK_TYPE_FUNCTION:\n\n                        switch (token.subtype) {\n\n                        case TOK_SUBTYPE_START:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfunctionStack.push({\n\t\t\t\t\t\t\t\tname: tokenString,\n\t\t\t\t\t\t\t\targumentNumber: 0\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\toutstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\n\t\t\t\t\t\t\tuseTemplate = true;\n\t\t\t\t\t\t\t\n                            break;\n                        case TOK_SUBTYPE_STOP:\n\n                            useTemplate = true;\n\t\t\t\t\t\t\tswitch (currentFunctionOnStack.name.toLowerCase()){\n                            case \"if\":\n                                outstr = \")\";\n                                useTemplate = false;\n\t\t\t\t\t\t\t\tbreak;\n                            default:\n                                outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\n\t\t\t\t\t\t\t\tbreak\n                            }\n                            functionStack.pop();\n                            break;\n                        }\n\n                        break;\n\n                    case TOK_TYPE_ARGUMENT:\n                        switch (currentFunctionOnStack.name.toLowerCase()){\n\t\t\t\t\t\tcase \"if\":\n                            switch (currentFunctionOnStack.argumentNumber) {\n                            case 0:\n                                outstr = \"?\";\n                                break;\n                            case 1:\n                                outstr = \":\";\n                                break;\n                            }\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\toutstr = \"+\";\n\t\t\t\t\t\t\tbreak;\n                        default:\n                            outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\n                            useTemplate = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n                        currentFunctionOnStack.argumentNumber += 1;\n\n                        break;\n\n                    default:\n                        outstr = typeof directConversionMap[tokenString] === \"string\" ? directConversionMap[tokenString] : tokenString;\n                        useTemplate = true;\n                        break;\n                    }\n\n                    return {\n                        tokenString: outstr,\n                        useTemplate: useTemplate\n                    };\n                };\n\n            var cSharpOutput = formatFormula(\n            formula, {\n                tmplFunctionStart: '{{token}}(',\n                tmplFunctionStop: '{{token}})',\n                tmplOperandError: '{{token}}',\n                tmplOperandRange: '{{token}}',\n                tmplOperandLogical: '{{token}}',\n                tmplOperandNumber: '{{token}}',\n                tmplOperandText: '\"{{token}}\"',\n                tmplArgument: '{{token}}',\n                tmplFunctionStartArray: \"\",\n                tmplFunctionStartArrayRow: \"{\",\n                tmplFunctionStopArrayRow: \"}\",\n                tmplFunctionStopArray: \"\",\n\t\t\t\ttmplSubexpressionStart: \"(\",\n\t\t\t\ttmplSubexpressionStop: \")\",\n                tmplIndentTab: \"\\t\",\n                tmplIndentSpace: \" \",\n                autoLineBreak: \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\",\n                trim: true,\n                customTokenRender: tokRender\n            });\n            return cSharpOutput;\n        };\n\t\n\t/**\n     * Both the csharp and javascript are the same when converted, this is just an alias for convert2CSharp. there are some subtle differences such as == vrs ===, this will be addressed in a later version.\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n\tvar formula2JavaScript = excelFormulaUtilities.formula2JavaScript = function (formula) {\n\t\t\treturn formula2CSharp(formula);\n\t\t}\n}());"]],"start1":0,"start2":0,"length1":0,"length2":45556}]],"length":45556}
